---
title: "Creando Inputs y Outputs Personalizados para Shiny"
subtitle: "MÃ¡s AllÃ¡ de los Widgets Incorporados"
author: "LatinR 2025"
format:
  revealjs:
    theme: [default, custom.scss]
    slide-number: true
    preview-links: auto
    code-line-numbers: false
    highlight-style: github
    transition: fade
    footer: "Bindings Personalizados en Shiny | LatinR 2025"
    logo: ""
    view-distance: 50
    mobile-view-distance: 50
    mermaid:
      theme: neutral
execute:
  echo: true
  eval: false
---

# Bienvenida {background-color="#2c3e50"}

## Agenda del Taller (90 min)

| Tiempo | Segmento |
|--------|----------|
| 0:00â€“0:05 | Bienvenida y orientaciÃ³n |
| 0:05â€“0:15 | Fundamentos: CÃ³mo funcionan los bindings |
| 0:15â€“0:55 | **Ejercicio 1:** Input binding personalizado |
| 0:55â€“1:00 | Pausa corta |
| 1:00â€“1:20 | **Ejercicio 2:** Output binding personalizado |
| 1:20â€“1:30 | Cierre y prÃ³ximos pasos |

## Objetivos de Aprendizaje

Al finalizar este taller podrÃ¡s:

1. **Entender** cÃ³mo el sistema de bindings de Shiny conecta el navegador con R
2. **Construir** un input binding personalizado (toggle tri-estado)
3. **Construir** un output binding personalizado (tarjeta de estadÃ­sticas)
4. **Conocer** recursos para implementaciones mÃ¡s avanzadas

## VerificaciÃ³n del Entorno

Antes de comenzar, verifica que puedas ejecutar la demo:

```r
# Abre el archivo y ejecuta la app
# 00-demo-finished/app.R
```

::: {.callout-tip}
Si ves el toggle de tres estados y la tarjeta de estadÃ­sticas funcionando, Â¡estÃ¡s listo!
:::

## Estructura del Repositorio

```
workshop-custom-shiny/
â”œâ”€â”€ 00-demo-finished/      # Demo completa
â”œâ”€â”€ 01-input-starter/      # Ejercicio 1 (esqueleto)
â”œâ”€â”€ 02-input-solution/     # Ejercicio 1 (soluciÃ³n)
â”œâ”€â”€ 03-output-starter/     # Ejercicio 2 (esqueleto)
â”œâ”€â”€ 04-output-solution/    # Ejercicio 2 (soluciÃ³n)
â””â”€â”€ reference/             # Recursos adicionales
```

## Herramientas de Debugging

::: {.columns}
::: {.column width="50%"}
### En R: `browser()`

```r
server <- function(input, output) {
  observe({
    browser()  # Pausa aquÃ­
    print(input$mi_input)
  })
}
```

Pausa la ejecuciÃ³n en R. Usa `n` (next), `c` (continue), `Q` (quit).
:::

::: {.column width="50%"}
### En JavaScript: `debugger`

```javascript
getValue: function(el) {
  debugger;  // Pausa aquÃ­
  return $(el).data('selected');
}
```

Abre DevTools (F12) antes. La ejecuciÃ³n pausa en esa lÃ­nea.
:::
:::

::: {.callout-tip}
Usaremos estas herramientas durante los ejercicios para ver el flujo de ejecuciÃ³n.
:::

# Fundamentos Conceptuales {background-color="#2c3e50"}

## Â¿QuÃ© es el DOM?

El **DOM** (Document Object Model) es la representaciÃ³n en memoria de la pÃ¡gina web.

```html
<div id="miInput" class="mi-clase">
  <button data-value="1">OpciÃ³n 1</button>
  <button data-value="2">OpciÃ³n 2</button>
</div>
```

JavaScript puede leer y modificar el DOM para cambiar lo que ve el usuario.

::: {.callout-tip}
Piensa en el DOM como un Ã¡rbol de elementos HTML que JavaScript puede manipular.
:::

## Selectores CSS en JavaScript

jQuery usa **selectores CSS** para encontrar elementos:

| Selector | Encuentra | Ejemplo |
|----------|-----------|---------|
| `.clase` | Elementos con esa clase | `$('.mi-clase')` |
| `#id` | Elemento con ese ID | `$('#miInput')` |
| `[attr="valor"]` | Elementos con ese atributo | `$('[data-value="1"]')` |

```javascript
// Encontrar todos los botones dentro de .mi-clase
$('.mi-clase').find('button')
```

## Â¿CÃ³mo se Comunican R y JavaScript?

::: {.columns}
::: {.column width="50%"}
### El Navegador (JavaScript)
- Maneja la interfaz de usuario
- Detecta eventos del usuario
- Actualiza el DOM
:::

::: {.column width="50%"}
### El Servidor (R)
- Ejecuta la lÃ³gica de negocio
- Procesa datos
- Genera outputs reactivos
:::
:::

::: {.fragment}
**WebSocket**: ConexiÃ³n bidireccional persistente que permite mensajes en tiempo real en ambas direcciones.
:::

## El Flujo de ComunicaciÃ³n

![](images/flow-diagram.png){fig-align="center" width="100%"}

## Dos Registros Centrales

Shiny mantiene dos registros para gestionar componentes:

```javascript
// Registro de inputs
Shiny.inputBindings.register(myInputBinding, 'pkg.myInput');

// Registro de outputs
Shiny.outputBindings.register(myOutputBinding, 'pkg.myOutput');
```

::: {.callout-note}
**Â¿QuÃ© hace `register()`?** AÃ±ade tu binding a la lista de Shiny. El segundo parÃ¡metro (`'pkg.myInput'`) es un identificador Ãºnico que ayuda a debuggear y permite que bindings con mayor prioridad tomen precedencia.
:::

## AnatomÃ­a de un Componente Personalizado

::: {.columns}
::: {.column width="50%"}
### Lado R
1. FunciÃ³n UI que genera HTML
2. Dependencias CSS/JS
3. FunciÃ³n render (outputs)
4. FunciÃ³n update (inputs)
:::

::: {.column width="50%"}
### Lado JavaScript
1. Clase que extiende el binding base
2. MÃ©todos requeridos
3. Registro en Shiny
:::
:::

## Input Binding: MÃ©todos Esenciales

| MÃ©todo | PropÃ³sito |
|--------|-----------|
| `find(scope)` | Localiza instancias del input en el DOM |
| `getValue(el)` | Extrae el valor actual para enviar a R |
| `subscribe(el, callback)` | Configura listeners de eventos |
| `setValue(el, value)` | Establece el valor programÃ¡ticamente |
| `receiveMessage(el, data)` | Maneja mensajes desde R |

## Output Binding: MÃ©todos Esenciales

| MÃ©todo | PropÃ³sito |
|--------|-----------|
| `find(scope)` | Localiza instancias del output en el DOM |
| `renderValue(el, data)` | Renderiza los datos recibidos de R |
| `renderError(el, err)` | Muestra errores (opcional) |
| `clearError(el)` | Limpia mensajes de error (opcional) |

## El PatrÃ³n es Consistente

::: {.callout-important}
Una vez que entiendes el patrÃ³n de input binding (`find` â†’ `getValue` â†’ `subscribe`), puedes construir **cualquier** input.

Una vez que entiendes el patrÃ³n de output (`find` â†’ `renderValue`), puedes renderizar **cualquier cosa**.
:::

# Ejercicio 1: Input Binding {background-color="#27ae60"}

## Â¿QuÃ© Vamos a Construir?

Un **toggle de tres estados** para filtrar tareas:

- **Todas**: Muestra todas las tareas
- **Activas**: Solo tareas pendientes
- **Completadas**: Solo tareas terminadas

::: {.fragment}
Este componente demuestra que `getValue()` puede retornar cualquier tipo de dato, no solo booleanos.
:::

## Estructura del Ejercicio

```
01-input-starter/
â”œâ”€â”€ app.R                    # App de Shiny
â”œâ”€â”€ R/
â”‚   â””â”€â”€ triStateInput.R      # Funciones R (completas)
â””â”€â”€ www/
    â”œâ”€â”€ css/
    â”‚   â””â”€â”€ tristate.css     # Estilos (completos)
    â””â”€â”€ js/
        â””â”€â”€ tristate.js      # Â¡AQUÃ TRABAJAREMOS!
```

::: {.callout-note}
**Â¿Por quÃ© `www/`?** Shiny sirve automÃ¡ticamente los archivos en esta carpeta. Cualquier archivo en `www/` estÃ¡ disponible en la URL de tu app.
:::

## Â¿CÃ³mo se Cargan CSS y JavaScript?

La funciÃ³n `htmlDependency()` le dice a Shiny quÃ© archivos incluir:

```r
triStateDependency <- function() {
  htmltools::htmlDependency(
    name = "tristate",
    version = "1.0.0",
    src = c(file = "www"),        # Carpeta donde estÃ¡n los archivos
    stylesheet = "css/tristate.css",
    script = "js/tristate.js"
  )
}
```

::: {.callout-tip}
Shiny solo carga cada dependencia **una vez**, aunque la uses mÃºltiples veces.
:::

## El Lado R Ya EstÃ¡ Completo

```r
triStateInput <- function(inputId, label, choices, selected = NULL) {
  tagList(
    triStateDependency(),
    tags$div(
      id = inputId,
      class = "tri-state-input",
      `data-selected` = selected,
      tags$label(class = "control-label", label),
      tags$div(class = "tri-state-options", ...)
    )
  )
}
```

## Conceptos Clave de JavaScript

Antes de ver el cÃ³digo, tres conceptos importantes:

**`$.extend(objeto, {...})`**: AÃ±ade mÃ©todos a un objeto existente. Es como agregar funciones a una clase.

**`scope`**: El Ã¡rea del DOM donde Shiny busca elementos. Normalmente es todo el documento, pero en modales o UI dinÃ¡mica puede ser solo una secciÃ³n.

**`callback`**: Una funciÃ³n que Shiny te pasa para que la llames cuando el valor cambie. Al llamar `callback()`, le dices a Shiny "Â¡el valor cambiÃ³, actualiza R!"

## El Esqueleto de JavaScript

```{.javascript filename="www/js/tristate.js"}
var triStateBinding = new Shiny.InputBinding();

$.extend(triStateBinding, {
  find: function(scope) {
    // TU CÃ“DIGO AQUÃ
  },
  getValue: function(el) {
    // TU CÃ“DIGO AQUÃ
  },
  subscribe: function(el, callback) {
    // TU CÃ“DIGO AQUÃ
  },
  // ... mÃ¡s mÃ©todos
});

Shiny.inputBindings.register(triStateBinding, 'workshop.triStateInput');
```

## Paso 1: Implementar `find()`

El mÃ©todo `find()` localiza todas las instancias del input en el DOM.

```javascript
find: function(scope) {
  return $(scope).find('.tri-state-input');
}
```

::: {.callout-tip}
Usa selectores de clase (`.clase`) en lugar de ID para soportar mÃºltiples instancias.
:::

## Paso 2: Implementar `getValue()`

El mÃ©todo `getValue()` extrae el valor actual del elemento.

```javascript
getValue: function(el) {
  return $(el).data('selected');
}
```

::: {.callout-warning}
**Error comÃºn:** Olvidar el `return`. Sin Ã©l, el binding falla silenciosamente y R recibe `NULL`.
:::

## Checkpoint 1

DespuÃ©s de implementar `find()` y `getValue()`:

- [ ] Sin errores de JavaScript en la consola
- [ ] El cuadro "Valor actual" muestra `"all"` (no `NULL`)

```r
# En la consola de R, deberÃ­as ver:
input$task_filter
# [1] "all"
```

## Paso 3: Implementar `subscribe()`

El mÃ©todo `subscribe()` configura los event listeners.

```javascript
subscribe: function(el, callback) {
  $(el).on('click.triStateBinding', '.tri-state-option', function(e) {
    var value = $(this).data('value');
    $(el).data('selected', value);

    // Actualizar estado visual
    $(el).find('.tri-state-option').removeClass('active');
    $(this).addClass('active');

    callback();
  });
}
```

## Namespacing de Eventos

```javascript
// âœ… Correcto: usa namespace
$(el).on('click.triStateBinding', handler);

// âŒ Incorrecto: sin namespace
$(el).on('click', handler);
```

::: {.callout-note}
**Â¿QuÃ© es `unsubscribe()`?** Shiny lo llama cuando el elemento se remueve del DOM. Si usas namespace, puedes implementarlo asÃ­:

```javascript
unsubscribe: function(el) {
  $(el).off('.triStateBinding');  // Remueve SOLO nuestros eventos
}
```
:::


## Checkpoint 2

DespuÃ©s de implementar `subscribe()`:

- [ ] Al hacer clic en las opciones, cambia el valor en R
- [ ] La tabla de tareas se filtra correctamente
- [ ] El estado visual (botÃ³n activo) se actualiza

## Paso 4: Implementar `setValue()` y `receiveMessage()`

Para que `updateTriStateInput()` funcione desde R:

```javascript
setValue: function(el, value) {
  $(el).data('selected', value);
  $(el).find('.tri-state-option').removeClass('active');
  $(el).find('.tri-state-option[data-value="' + value + '"]').addClass('active');
},

receiveMessage: function(el, data) {
  if (data.hasOwnProperty('selected')) {
    this.setValue(el, data.selected);
    $(el).trigger('change');
  }
}
```

## Â¿Por quÃ© `.trigger('change')`?

El flujo cuando R actualiza un input:

1. R llama `updateTriStateInput()` â†’ envÃ­a mensaje por WebSocket
2. JavaScript recibe en `receiveMessage()` â†’ llama `setValue()`
3. `setValue()` actualiza el DOM, pero... **Shiny no sabe que cambiÃ³**
4. `.trigger('change')` dispara el evento â†’ `subscribe()` lo escucha â†’ llama `callback()`
5. Ahora Shiny sabe que debe llamar `getValue()` y actualizar R

::: {.callout-warning}
Sin `.trigger('change')`, el valor cambia visualmente pero R nunca se entera.
:::

## TambiÃ©n necesitamos escuchar 'change'

```javascript
subscribe: function(el, callback) {
  $(el).on('click.triStateBinding', '.tri-state-option', function(e) {
    // ... cÃ³digo de click ...
    callback();
  });

  // Para receiveMessage
  $(el).on('change.triStateBinding', function(e) {
    callback();
  });
}
```

## Checkpoint 3

DespuÃ©s de implementar `setValue()` y `receiveMessage()`:

- [ ] El botÃ³n "Restablecer a 'Todas'" funciona
- [ ] Al hacer clic, el toggle vuelve a "Todas"
- [ ] La tabla muestra todas las tareas

## SoluciÃ³n Completa del Input Binding

```{.javascript code-line-numbers="|3-5|7-9|11-21|23-27|29-33"}
var triStateBinding = new Shiny.InputBinding();

$.extend(triStateBinding, {
  find: function(scope) {
    return $(scope).find('.tri-state-input');
  },

  getValue: function(el) {
    return $(el).data('selected');
  },

  subscribe: function(el, callback) {
    $(el).on('click.triStateBinding', '.tri-state-option', function(e) {
      var value = $(this).data('value');
      $(el).data('selected', value);
      $(el).find('.tri-state-option').removeClass('active');
      $(this).addClass('active');
      callback();
    });
    $(el).on('change.triStateBinding', function(e) {
      callback();
    });
  },

  setValue: function(el, value) {
    $(el).data('selected', value);
    $(el).find('.tri-state-option').removeClass('active');
    $(el).find('.tri-state-option[data-value="' + value + '"]').addClass('active');
  },

  receiveMessage: function(el, data) {
    if (data.hasOwnProperty('selected')) {
      this.setValue(el, data.selected);
      $(el).trigger('change');
    }
  }
});

Shiny.inputBindings.register(triStateBinding, 'workshop.triStateInput');
```

## ExtensiÃ³n: Rate Policy

Si hay tiempo, aÃ±ade limitaciÃ³n de frecuencia:

```javascript
getRatePolicy: function() {
  return { policy: 'debounce', delay: 250 };
}
```

**PolÃ­ticas disponibles:**

- `direct`: EnvÃ­a inmediatamente
- `debounce`: Espera hasta que no haya nuevos valores
- `throttle`: MÃ¡ximo un envÃ­o por perÃ­odo

## ExtensiÃ³n: Tipos de Datos en getValue()

`getValue()` puede retornar cualquier valor serializable a JSON:

| JavaScript | R |
|------------|---|
| `"texto"` | `"texto"` (character) |
| `123` | `123` (numeric) |
| `true/false` | `TRUE/FALSE` (logical) |
| `[1, 2, 3]` | `c(1, 2, 3)` (vector) |
| `{a: 1, b: 2}` | `list(a = 1, b = 2)` |

La conversiÃ³n es automÃ¡tica vÃ­a JSON.

## ExtensiÃ³n: Input Handlers Personalizados

Para tipos especiales (ej: fechas), usa `getType()` + `registerInputHandler()`:

::: {.columns}
::: {.column width="50%"}
**JavaScript:**
```javascript
getType: function(el) {
  return "mipaquete.fecha";
}
```
:::

::: {.column width="50%"}
**R (en .onLoad):**
```r
registerInputHandler(
 "mipaquete.fecha",
 function(x, session, name) {
   as.Date(x)
 }
)
```
:::
:::

Handlers incluidos: `shiny.date`, `shiny.number`, `shiny.matrix`

# Pausa (5 min) {background-color="#7f8c8d"}

::: {.r-fit-text}
Â¡Estira las piernas!
:::

# Ejercicio 2: Output Binding {background-color="#e74c3c"}

## Â¿QuÃ© Vamos a Construir?

Una **tarjeta de estadÃ­sticas** que:

- Muestra un tÃ­tulo y un valor numÃ©rico
- Cambia de color segÃºn umbrales (verde/amarillo/rojo)
- Se actualiza reactivamente desde R

## Estructura del Ejercicio

```
03-output-starter/
â”œâ”€â”€ app.R                    # App de Shiny
â”œâ”€â”€ R/
â”‚   â””â”€â”€ statCard.R           # Funciones R (completas)
â””â”€â”€ www/
    â”œâ”€â”€ css/
    â”‚   â””â”€â”€ statcard.css     # Estilos (completos)
    â””â”€â”€ js/
        â””â”€â”€ statcard.js      # Â¡AQUÃ TRABAJAREMOS!
```

## El Lado R Ya EstÃ¡ Completo

```r
statCardOutput <- function(outputId, width = "200px") {
  tagList(
    statCardDependency(),
    tags$div(
      id = outputId,
      class = "stat-card",
      style = paste0("width: ", width, ";"),
      tags$div(class = "stat-title", "Loading..."),
      tags$div(class = "stat-value", "--")
    )
  )
}
```

## La FunciÃ³n Render en R

```r
renderStatCard <- function(expr) {
  func <- shiny::quoToFunction(rlang::enquo0(expr))

  shiny::createRenderFunction(
    func,
    transform = function(value, session, name, ...) {
      list(
        title = value$title,
        value = value$value,
        status = value$status
      )
    },
    outputFunc = statCardOutput
  )
}
```

## Â¿QuÃ© hace `transform`?

`transform` procesa el resultado de la expresiÃ³n antes de que Shiny lo serialice:

::: {.columns}
::: {.column width="45%"}
**Resultado de expr:**
```r
list(
  title = "Score",
  value = 75,
  status = "good",
  extra_data = "..."
)
```
:::
::: {.column width="55%"}
**DespuÃ©s de transform:**
```r
list(
  title = value$title,
  value = value$value,
  status = value$status
)
```
:::
:::

::: {.callout-note}
**`transform`** extrae solo los campos necesarios. Luego Shiny serializa el resultado a JSON y lo envÃ­a al binding vÃ­a WebSocket.
:::

## Â¿Por quÃ© usar una lista simple?

En `renderStatCard`, el usuario pasa una lista directamente:

```r
output$card <- renderStatCard({
  list(title = "Score", value = 75, status = "good")
})
```

::: {.callout-tip}
## Alternativas de diseÃ±o

1. **FunciÃ³n auxiliar**: `statCardData("Score", 75, "good")` â†’ mÃ¡s legible
2. **Estilo htmlwidgets**: `statCard(...)` retorna objeto especial que `renderStatCard` detecta
3. **Lista simple** (nuestra elecciÃ³n): ExplÃ­cito, sin magia, fÃ¡cil de entender

Para un workshop, preferimos claridad sobre conveniencia.
:::

## El Esqueleto de JavaScript

```{.javascript filename="www/js/statcard.js"}
var statCardBinding = new Shiny.OutputBinding();

$.extend(statCardBinding, {
  find: function(scope) {
    // TU CÃ“DIGO AQUÃ
  },
  renderValue: function(el, data) {
    // TU CÃ“DIGO AQUÃ
  }
});

Shiny.outputBindings.register(statCardBinding, 'workshop.statCard');
```

## Paso 1: Implementar `find()`

IdÃ©ntico al patrÃ³n de input bindings:

```javascript
find: function(scope) {
  return $(scope).find('.stat-card');
}
```

## Paso 2: Implementar `renderValue()`

Este mÃ©todo recibe los datos de R y actualiza el DOM:

```javascript
renderValue: function(el, data) {
  // Actualizar tÃ­tulo y valor
  $(el).find('.stat-title').text(data.title);
  $(el).find('.stat-value').text(data.value);

  // Actualizar clase de estado
  $(el).removeClass('status-good status-warning status-bad');
  if (data.status) {
    $(el).addClass('status-' + data.status);
  }
}
```

## Los Datos Llegan como JSON

En R enviamos:

```r
list(title = "PuntuaciÃ³n", value = 75, status = "warning")
```

En JavaScript recibimos:

```javascript
{
  title: "PuntuaciÃ³n",
  value: 75,
  status: "warning"
}
```

## Checkpoint Final

DespuÃ©s de implementar ambos mÃ©todos:

- [ ] La tarjeta muestra el tÃ­tulo y el valor
- [ ] Al mover el slider, el valor se actualiza
- [ ] El color cambia segÃºn los umbrales:
  - ğŸŸ¢ Verde: 80-100
  - ğŸŸ¡ Amarillo: 50-79
  - ğŸ”´ Rojo: 0-49

## SoluciÃ³n Completa del Output Binding

```{.javascript code-line-numbers="|3-5|7-15"}
var statCardBinding = new Shiny.OutputBinding();

$.extend(statCardBinding, {
  find: function(scope) {
    return $(scope).find('.stat-card');
  },

  renderValue: function(el, data) {
    $(el).find('.stat-title').text(data.title);
    $(el).find('.stat-value').text(data.value);

    $(el).removeClass('status-good status-warning status-bad');
    if (data.status) {
      $(el).addClass('status-' + data.status);
    }
  }
});

Shiny.outputBindings.register(statCardBinding, 'workshop.statCard');
```

# ExtensiÃ³n: Outputs que Generan Inputs {background-color="#9b59b6"}

## El PatrÃ³n de DT, plotly y leaflet

Â¿CÃ³mo funciona `input$tabla_rows_selected` en DT?

Los outputs pueden crear **inputs sintÃ©ticos** usando `Shiny.setInputValue()`:

```javascript
renderValue: function(el, data) {
  var outputId = el.id;  // ej: "miTabla"

  // Renderizar el output normalmente...

  // Crear un input cuando el usuario interactÃºa
  $(el).on('click', '.row', function() {
    var selected = /* obtener selecciÃ³n */;
    Shiny.setInputValue(outputId + '_selected', selected);
  });
}
```

En R: `input$miTabla_selected`

## Shiny.setInputValue()

```javascript
// Sintaxis bÃ¡sica
Shiny.setInputValue("inputId", valor);

// Con namespace (dentro de mÃ³dulos)
Shiny.setInputValue(outputId + "_clicked", valor);

// Como evento (notifica aunque el valor no cambie)
Shiny.setInputValue("inputId", valor, {priority: "event"});
```

::: {.callout-tip}
No necesitas crear un input binding formal - `setInputValue()` crea el input directamente.
:::

## Ejemplo: Stat Card Clickeable

```javascript
renderValue: function(el, data) {
  // Renderizar como antes...
  $(el).find('.stat-title').text(data.title);
  $(el).find('.stat-value').text(data.value);

  // Agregar interactividad
  $(el).off('click').on('click', function() {
    Shiny.setInputValue(
      el.id + '_clicked',
      data.value,
      {priority: 'event'}
    );
  });
}
```

En R: `observeEvent(input$miCard_clicked, { ... })`

# Cierre y PrÃ³ximos Pasos {background-color="#2c3e50"}

## RecapitulaciÃ³n

::: {.columns}
::: {.column width="50%"}
### Input Bindings

1. `find()` - Localizar elementos
2. `getValue()` - Extraer valor
3. `subscribe()` - Escuchar eventos
4. `setValue()` - Establecer valor
5. `receiveMessage()` - Recibir de R
:::

::: {.column width="50%"}
### Output Bindings

1. `find()` - Localizar elementos
2. `renderValue()` - Renderizar datos

(Â¡MÃ¡s simple!)
:::
:::

## El PatrÃ³n Escala

Estos patrones son la base de paquetes como:

- **shinyWidgets**: Decenas de inputs personalizados de producciÃ³n
- **htmlwidgets**: Framework para bindear librerÃ­as JavaScript
- **shiny.react**: Componentes React en Shiny
- **plotly**, **leaflet**, **DT**: Widgets interactivos

## Â¿QuÃ© es htmlwidgets?

Un **framework** para crear widgets R que envuelven librerÃ­as JavaScript.

```r
# Genera estructura inicial del paquete
htmlwidgets::scaffoldWidget("miWidget")
```

Esto crea automÃ¡ticamente:

- Archivos `.R`, `.js`, `.yaml` necesarios
- Output binding de Shiny pre-configurado
- IntegraciÃ³n con RMarkdown/Quarto

## Bindings Personalizados vs htmlwidgets

| Aspecto | Bindings Personalizados | htmlwidgets |
|---------|------------------------|-------------|
| **Caso de uso** | Inputs y outputs simples | Visualizaciones complejas |
| **Dependencias** | Solo Shiny | Framework adicional |
| **Control** | Total sobre el cÃ³digo | Convenciones del framework |
| **Curva** | Entender el protocolo | Aprender htmlwidgets API |
| **Ejemplos** | Botones, selectores, cards | GrÃ¡ficos D3, mapas, tablas |

## Â¿CuÃ¡ndo usar cada uno?

::: {.columns}
::: {.column width="50%"}
### Bindings Personalizados

- Input que no existe en Shiny
- Output con lÃ³gica simple
- Control total del comportamiento
- Sin dependencias adicionales
- **Lo que aprendimos hoy**
:::

::: {.column width="50%"}
### htmlwidgets

- Envolver librerÃ­a JS existente
- Visualizaciones interactivas
- Reutilizar en RMarkdown/Quarto
- Ecosistema establecido
- Ejemplos: plotly, leaflet, DT
:::
:::

## Recursos para Profundizar

| Recurso | Mejor para |
|---------|------------|
| *Outstanding User Interfaces with Shiny* (Granjon) | Internos de bindings |
| *JavaScript for R* (Coene) | Fundamentos de JS en contexto R |
| DocumentaciÃ³n de htmlwidgets | Outputs de visualizaciÃ³n D3.js |
| posit-dev/shiny-bindings | Patrones emergentes, React |

## Referencias Clave

- Posit. "How to Create Custom Input Bindings." 2024.
  <https://shiny.posit.co/r/articles/build/js-custom-input/>

- Posit. "Build Custom Output Objects." 2024.
  <https://shiny.posit.co/r/articles/build/building-outputs/>

- Granjon, David. *Outstanding User Interfaces with Shiny*. Chapman and Hall/CRC, 2022.
  <https://unleash-shiny.rinterface.com/>

## SoluciÃ³n de Problemas Comunes

| Problema | SoluciÃ³n |
|----------|----------|
| "La app no corre" | Verificar directorio de trabajo |
| "Los cambios no aparecen" | Hard refresh (Ctrl+Shift+R) |
| "Error de JavaScript en consola" | Revisar comas y punto y coma |
| "El valor es undefined en R" | Verificar `return` en `getValue()` |

## Â¡Gracias!

::: {.r-fit-text}
**Â¡Han construido un input y un output personalizados desde cero!**
:::

::: {.fragment}
El patrÃ³n siempre es el mismo:

**R genera HTML â†’ JavaScript maneja comportamiento â†’ WebSocket los conecta**

Todo lo demÃ¡s son variaciones de este tema.
:::

## Contacto y Materiales

::: {.columns}
::: {.column width="50%"}
### Repositorio

Todo el cÃ³digo estÃ¡ disponible en:

[github.com/...](https://github.com/)
:::

::: {.column width="50%"}
### Preguntas

Â¿Preguntas ahora o despuÃ©s?

[correo@ejemplo.com](mailto:correo@ejemplo.com)
:::
:::
