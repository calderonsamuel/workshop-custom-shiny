[
  {
    "objectID": "reference/resources.html",
    "href": "reference/resources.html",
    "title": "Resources: Custom Shiny Inputs and Outputs",
    "section": "",
    "text": "Method\nRequired\nPurpose\n\n\n\n\nfind(scope)\nYes\nLocate all instances of your input in the DOM\n\n\ngetValue(el)\nYes\nExtract current value to send to R\n\n\nsubscribe(el, callback)\nYes\nSet up event listeners for value changes\n\n\nunsubscribe(el)\nNo\nClean up event listeners\n\n\nsetValue(el, value)\nNo\nProgrammatically set the value\n\n\nreceiveMessage(el, data)\nNo\nHandle messages from R (for update functions)\n\n\ngetRatePolicy()\nNo\nControl update frequency (debounce/throttle)\n\n\ngetType()\nNo\nSpecify custom R input handler\n\n\ninitialize(el)\nNo\nOne-time setup when binding is first attached\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMethod\nRequired\nPurpose\n\n\n\n\nfind(scope)\nYes\nLocate all instances of your output in the DOM\n\n\nrenderValue(el, data)\nYes\nRender data from R into the DOM element\n\n\nrenderError(el, error)\nNo\nDisplay error messages\n\n\nclearError(el)\nNo\nClear error display\n\n\n\n\n\n\ngetRatePolicy: function() {\n  return { policy: 'debounce', delay: 250 };\n}\n\ndirect ‚Äî Send immediately (no rate limiting)\ndebounce ‚Äî Wait until no new values for delay ms (good for text inputs)\nthrottle ‚Äî Send at most once per delay ms (good for sliders)\n\n\n\n\n\n\n\n\n\nHow to Create Custom Input Bindings Essential guide covering the InputBinding class and all its methods.\nBuild Custom Output Objects Guide to creating custom output bindings.\nCommunicating with Shiny via JavaScript Covers Shiny.setInputValue(), custom message handlers, and more.\nPackaging JavaScript Code for Shiny Best practices for including JS/CSS in packages.\n\n\n\n\n\nCreating a Widget If you need to wrap a JavaScript visualization library.\nWidget Sizing Handle responsive sizing across different contexts.\n\n\n\n\n\n\n\n\nDavid Granjon (Chapman and Hall/CRC, 2022) https://unleash-shiny.rinterface.com/\nThe most comprehensive resource for custom bindings. Chapters 6-7 cover input and output bindings in depth, with many real-world examples.\n\n\n\nJohn Coene (Chapman and Hall/CRC, 2021) https://javascript-for-r.com/\nExcellent introduction to JavaScript for R users. Covers the basics you need to understand before diving into custom bindings.\n\n\n\nHadley Wickham (O‚ÄôReilly Media, 2021) https://mastering-shiny.org/\nComprehensive Shiny guide. While it doesn‚Äôt cover custom bindings in depth, it provides essential context on reactivity and Shiny architecture.\n\n\n\nColin Fay, S√©bastien Rochette, Vincent Guyader, Cervan Girard (Chapman and Hall/CRC, 2021) https://engineering-shiny.org/\nFocus on building robust, maintainable Shiny apps. Good for understanding how custom components fit into larger applications.\n\n\n\n\n\n\n\nhttps://github.com/dreamRs/shinyWidgets\nDozens of production-quality input bindings. Excellent source code to study for patterns and best practices.\n\n\n\nhttps://github.com/daattali/shinyjs\nShows how to execute JavaScript from R without full binding infrastructure. Good for simpler use cases.\n\n\n\nhttps://github.com/ramnathv/htmlwidgets\nFramework for wrapping JavaScript libraries. Powers plotly, leaflet, DT, and many other visualization packages.\n\n\n\nhttps://github.com/react-R/reactR\nFor integrating React components with Shiny.\n\n\n\nhttps://github.com/Appsilon/shiny.react\nAlternative approach to React integration.\n\n\n\n\n\n\n\nhttps://github.com/posit-dev/shiny-bindings\nEmerging patterns for custom bindings, including React component integration.\n\n\n\nhttps://github.com/rstudio/shiny\nThe Shiny source code itself. Look at inst/www/shared/shiny.js to understand how built-in bindings work.\n\n\n\n\n\n\n\noptions(shiny.trace = TRUE)\nShows all messages between browser and R server.\n\n\n\nreactlog::reactlog_enable()\n# Run your app, then:\nshiny::reactlogShow()\nVisualize the reactive dependency graph.\n\n\n\n\nConsole: Check for JavaScript errors\nNetwork tab: Inspect WebSocket messages\nElements tab: Verify HTML structure matches your expectations\n\n\n\n\ngetValue: function(el) {\n  debugger;  // Execution pauses here when dev tools are open\n  return $(el).data('selected');\n}\n\n\n\n\n\n\n\nUse a &lt;script type=\"application/json\"&gt; tag to embed configuration:\n# R side\ntags$script(\n  type = \"application/json\",\n  `data-for` = inputId,\n  jsonlite::toJSON(config, auto_unbox = TRUE)\n)\n// JavaScript side\nvar config = JSON.parse(\n  $(el).find('script[data-for=\"' + el.id + '\"]').html()\n);\n\n\n\nShiny.setInputValue(\"inputId\", value);\n\n// For events that should always trigger, even with same value:\nShiny.setInputValue(\"inputId\", value, {priority: \"event\"});\n\n\n\n# In your package's .onLoad()\nshiny::registerInputHandler(\"mypackage.dateTime\", function(x, session, inputname) {\n  as.POSIXct(x, origin = \"1970-01-01\")\n})\n// In JavaScript, use colon syntax\nShiny.setInputValue(\"timestamp:mypackage.dateTime\", Date.now());\n\n\n\n# R server\nsession$sendCustomMessage(\"myHandler\", list(data = processed_data))\n// JavaScript\nShiny.addCustomMessageHandler(\"myHandler\", function(message) {\n  console.log(message.data);\n});\n\n\n\n\n\n\nStudy shinyWidgets source code ‚Äî Real production examples\nBuild a simple widget with htmlwidgets ‚Äî If you need visualizations\nRead ‚ÄúOutstanding User Interfaces with Shiny‚Äù ‚Äî Deep dive into advanced patterns\nExplore React integration ‚Äî If you‚Äôre comfortable with React"
  },
  {
    "objectID": "reference/resources.html#quick-reference",
    "href": "reference/resources.html#quick-reference",
    "title": "Resources: Custom Shiny Inputs and Outputs",
    "section": "",
    "text": "Method\nRequired\nPurpose\n\n\n\n\nfind(scope)\nYes\nLocate all instances of your input in the DOM\n\n\ngetValue(el)\nYes\nExtract current value to send to R\n\n\nsubscribe(el, callback)\nYes\nSet up event listeners for value changes\n\n\nunsubscribe(el)\nNo\nClean up event listeners\n\n\nsetValue(el, value)\nNo\nProgrammatically set the value\n\n\nreceiveMessage(el, data)\nNo\nHandle messages from R (for update functions)\n\n\ngetRatePolicy()\nNo\nControl update frequency (debounce/throttle)\n\n\ngetType()\nNo\nSpecify custom R input handler\n\n\ninitialize(el)\nNo\nOne-time setup when binding is first attached\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMethod\nRequired\nPurpose\n\n\n\n\nfind(scope)\nYes\nLocate all instances of your output in the DOM\n\n\nrenderValue(el, data)\nYes\nRender data from R into the DOM element\n\n\nrenderError(el, error)\nNo\nDisplay error messages\n\n\nclearError(el)\nNo\nClear error display\n\n\n\n\n\n\ngetRatePolicy: function() {\n  return { policy: 'debounce', delay: 250 };\n}\n\ndirect ‚Äî Send immediately (no rate limiting)\ndebounce ‚Äî Wait until no new values for delay ms (good for text inputs)\nthrottle ‚Äî Send at most once per delay ms (good for sliders)"
  },
  {
    "objectID": "reference/resources.html#official-documentation",
    "href": "reference/resources.html#official-documentation",
    "title": "Resources: Custom Shiny Inputs and Outputs",
    "section": "",
    "text": "How to Create Custom Input Bindings Essential guide covering the InputBinding class and all its methods.\nBuild Custom Output Objects Guide to creating custom output bindings.\nCommunicating with Shiny via JavaScript Covers Shiny.setInputValue(), custom message handlers, and more.\nPackaging JavaScript Code for Shiny Best practices for including JS/CSS in packages.\n\n\n\n\n\nCreating a Widget If you need to wrap a JavaScript visualization library.\nWidget Sizing Handle responsive sizing across different contexts."
  },
  {
    "objectID": "reference/resources.html#books",
    "href": "reference/resources.html#books",
    "title": "Resources: Custom Shiny Inputs and Outputs",
    "section": "",
    "text": "David Granjon (Chapman and Hall/CRC, 2022) https://unleash-shiny.rinterface.com/\nThe most comprehensive resource for custom bindings. Chapters 6-7 cover input and output bindings in depth, with many real-world examples.\n\n\n\nJohn Coene (Chapman and Hall/CRC, 2021) https://javascript-for-r.com/\nExcellent introduction to JavaScript for R users. Covers the basics you need to understand before diving into custom bindings.\n\n\n\nHadley Wickham (O‚ÄôReilly Media, 2021) https://mastering-shiny.org/\nComprehensive Shiny guide. While it doesn‚Äôt cover custom bindings in depth, it provides essential context on reactivity and Shiny architecture.\n\n\n\nColin Fay, S√©bastien Rochette, Vincent Guyader, Cervan Girard (Chapman and Hall/CRC, 2021) https://engineering-shiny.org/\nFocus on building robust, maintainable Shiny apps. Good for understanding how custom components fit into larger applications."
  },
  {
    "objectID": "reference/resources.html#packages-to-study",
    "href": "reference/resources.html#packages-to-study",
    "title": "Resources: Custom Shiny Inputs and Outputs",
    "section": "",
    "text": "https://github.com/dreamRs/shinyWidgets\nDozens of production-quality input bindings. Excellent source code to study for patterns and best practices.\n\n\n\nhttps://github.com/daattali/shinyjs\nShows how to execute JavaScript from R without full binding infrastructure. Good for simpler use cases.\n\n\n\nhttps://github.com/ramnathv/htmlwidgets\nFramework for wrapping JavaScript libraries. Powers plotly, leaflet, DT, and many other visualization packages.\n\n\n\nhttps://github.com/react-R/reactR\nFor integrating React components with Shiny.\n\n\n\nhttps://github.com/Appsilon/shiny.react\nAlternative approach to React integration."
  },
  {
    "objectID": "reference/resources.html#github-repositories",
    "href": "reference/resources.html#github-repositories",
    "title": "Resources: Custom Shiny Inputs and Outputs",
    "section": "",
    "text": "https://github.com/posit-dev/shiny-bindings\nEmerging patterns for custom bindings, including React component integration.\n\n\n\nhttps://github.com/rstudio/shiny\nThe Shiny source code itself. Look at inst/www/shared/shiny.js to understand how built-in bindings work."
  },
  {
    "objectID": "reference/resources.html#debugging-tips",
    "href": "reference/resources.html#debugging-tips",
    "title": "Resources: Custom Shiny Inputs and Outputs",
    "section": "",
    "text": "options(shiny.trace = TRUE)\nShows all messages between browser and R server.\n\n\n\nreactlog::reactlog_enable()\n# Run your app, then:\nshiny::reactlogShow()\nVisualize the reactive dependency graph.\n\n\n\n\nConsole: Check for JavaScript errors\nNetwork tab: Inspect WebSocket messages\nElements tab: Verify HTML structure matches your expectations\n\n\n\n\ngetValue: function(el) {\n  debugger;  // Execution pauses here when dev tools are open\n  return $(el).data('selected');\n}"
  },
  {
    "objectID": "reference/resources.html#common-patterns",
    "href": "reference/resources.html#common-patterns",
    "title": "Resources: Custom Shiny Inputs and Outputs",
    "section": "",
    "text": "Use a &lt;script type=\"application/json\"&gt; tag to embed configuration:\n# R side\ntags$script(\n  type = \"application/json\",\n  `data-for` = inputId,\n  jsonlite::toJSON(config, auto_unbox = TRUE)\n)\n// JavaScript side\nvar config = JSON.parse(\n  $(el).find('script[data-for=\"' + el.id + '\"]').html()\n);\n\n\n\nShiny.setInputValue(\"inputId\", value);\n\n// For events that should always trigger, even with same value:\nShiny.setInputValue(\"inputId\", value, {priority: \"event\"});\n\n\n\n# In your package's .onLoad()\nshiny::registerInputHandler(\"mypackage.dateTime\", function(x, session, inputname) {\n  as.POSIXct(x, origin = \"1970-01-01\")\n})\n// In JavaScript, use colon syntax\nShiny.setInputValue(\"timestamp:mypackage.dateTime\", Date.now());\n\n\n\n# R server\nsession$sendCustomMessage(\"myHandler\", list(data = processed_data))\n// JavaScript\nShiny.addCustomMessageHandler(\"myHandler\", function(message) {\n  console.log(message.data);\n});"
  },
  {
    "objectID": "reference/resources.html#next-steps-after-this-workshop",
    "href": "reference/resources.html#next-steps-after-this-workshop",
    "title": "Resources: Custom Shiny Inputs and Outputs",
    "section": "",
    "text": "Study shinyWidgets source code ‚Äî Real production examples\nBuild a simple widget with htmlwidgets ‚Äî If you need visualizations\nRead ‚ÄúOutstanding User Interfaces with Shiny‚Äù ‚Äî Deep dive into advanced patterns\nExplore React integration ‚Äî If you‚Äôre comfortable with React"
  },
  {
    "objectID": "index.html#agenda-del-taller-90-min",
    "href": "index.html#agenda-del-taller-90-min",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "Agenda del Taller (90 min)",
    "text": "Agenda del Taller (90 min)\n\n\n\nTiempo\nSegmento\n\n\n\n\n0:00‚Äì0:05\nBienvenida y orientaci√≥n\n\n\n0:05‚Äì0:15\nFundamentos: C√≥mo funcionan los bindings\n\n\n0:15‚Äì0:55\nEjercicio 1: Input binding personalizado\n\n\n0:55‚Äì1:00\nPausa corta\n\n\n1:00‚Äì1:20\nEjercicio 2: Output binding personalizado\n\n\n1:20‚Äì1:30\nCierre y pr√≥ximos pasos"
  },
  {
    "objectID": "index.html#objetivos-de-aprendizaje",
    "href": "index.html#objetivos-de-aprendizaje",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "Objetivos de Aprendizaje",
    "text": "Objetivos de Aprendizaje\nAl finalizar este taller podr√°s:\n\nEntender c√≥mo el sistema de bindings de Shiny conecta el navegador con R\nConstruir un input binding personalizado (toggle tri-estado)\nConstruir un output binding personalizado (tarjeta de estad√≠sticas)\nConocer recursos para implementaciones m√°s avanzadas"
  },
  {
    "objectID": "index.html#verificaci√≥n-del-entorno",
    "href": "index.html#verificaci√≥n-del-entorno",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "Verificaci√≥n del Entorno",
    "text": "Verificaci√≥n del Entorno\nAntes de comenzar, verifica que puedas ejecutar la demo:\n# Abre el archivo y ejecuta la app\n# 00-demo-finished/app.R\n\n\n\n\n\n\nTip\n\n\nSi ves el toggle de tres estados y la tarjeta de estad√≠sticas funcionando, ¬°est√°s listo!"
  },
  {
    "objectID": "index.html#estructura-del-repositorio",
    "href": "index.html#estructura-del-repositorio",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "Estructura del Repositorio",
    "text": "Estructura del Repositorio\nworkshop-custom-shiny/\n‚îú‚îÄ‚îÄ 00-demo-finished/      # Demo completa\n‚îú‚îÄ‚îÄ 01-input-starter/      # Ejercicio 1 (esqueleto)\n‚îú‚îÄ‚îÄ 02-input-solution/     # Ejercicio 1 (soluci√≥n)\n‚îú‚îÄ‚îÄ 03-output-starter/     # Ejercicio 2 (esqueleto)\n‚îú‚îÄ‚îÄ 04-output-solution/    # Ejercicio 2 (soluci√≥n)\n‚îî‚îÄ‚îÄ reference/             # Recursos adicionales"
  },
  {
    "objectID": "index.html#c√≥mo-se-comunican-r-y-javascript",
    "href": "index.html#c√≥mo-se-comunican-r-y-javascript",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "¬øC√≥mo se Comunican R y JavaScript?",
    "text": "¬øC√≥mo se Comunican R y JavaScript?\n\n\nEl Navegador (JavaScript)\n\nManeja la interfaz de usuario\nDetecta eventos del usuario\nActualiza el DOM\n\n\nEl Servidor (R)\n\nEjecuta la l√≥gica de negocio\nProcesa datos\nGenera outputs reactivos\n\n\n\nWebSocket: Conexi√≥n bidireccional persistente que permite mensajes en tiempo real en ambas direcciones."
  },
  {
    "objectID": "index.html#el-flujo-de-comunicaci√≥n",
    "href": "index.html#el-flujo-de-comunicaci√≥n",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "El Flujo de Comunicaci√≥n",
    "text": "El Flujo de Comunicaci√≥n"
  },
  {
    "objectID": "index.html#dos-registros-centrales",
    "href": "index.html#dos-registros-centrales",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "Dos Registros Centrales",
    "text": "Dos Registros Centrales\nShiny mantiene dos registros para gestionar componentes:\n// Registro de inputs\nShiny.inputBindings.register(myInputBinding, 'pkg.myInput');\n\n// Registro de outputs\nShiny.outputBindings.register(myOutputBinding, 'pkg.myOutput');\n\n\n\n\n\n\nNote\n\n\nCuando Shiny inicializa, llama a Shiny.bindAll() para escanear el DOM y asociar cada elemento con su binding correspondiente."
  },
  {
    "objectID": "index.html#anatom√≠a-de-un-componente-personalizado",
    "href": "index.html#anatom√≠a-de-un-componente-personalizado",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "Anatom√≠a de un Componente Personalizado",
    "text": "Anatom√≠a de un Componente Personalizado\n\n\nLado R\n\nFunci√≥n UI que genera HTML\nDependencias CSS/JS\nFunci√≥n render (outputs)\nFunci√≥n update (inputs)\n\n\nLado JavaScript\n\nClase que extiende el binding base\nM√©todos requeridos\nRegistro en Shiny"
  },
  {
    "objectID": "index.html#input-binding-m√©todos-esenciales",
    "href": "index.html#input-binding-m√©todos-esenciales",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "Input Binding: M√©todos Esenciales",
    "text": "Input Binding: M√©todos Esenciales\n\n\n\nM√©todo\nProp√≥sito\n\n\n\n\nfind(scope)\nLocaliza instancias del input en el DOM\n\n\ngetValue(el)\nExtrae el valor actual para enviar a R\n\n\nsubscribe(el, callback)\nConfigura listeners de eventos\n\n\nsetValue(el, value)\nEstablece el valor program√°ticamente\n\n\nreceiveMessage(el, data)\nManeja mensajes desde R"
  },
  {
    "objectID": "index.html#output-binding-m√©todos-esenciales",
    "href": "index.html#output-binding-m√©todos-esenciales",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "Output Binding: M√©todos Esenciales",
    "text": "Output Binding: M√©todos Esenciales\n\n\n\nM√©todo\nProp√≥sito\n\n\n\n\nfind(scope)\nLocaliza instancias del output en el DOM\n\n\nrenderValue(el, data)\nRenderiza los datos recibidos de R\n\n\nrenderError(el, err)\nMuestra errores (opcional)\n\n\nclearError(el)\nLimpia mensajes de error (opcional)"
  },
  {
    "objectID": "index.html#el-patr√≥n-es-consistente",
    "href": "index.html#el-patr√≥n-es-consistente",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "El Patr√≥n es Consistente",
    "text": "El Patr√≥n es Consistente\n\n\n\n\n\n\nImportant\n\n\nUna vez que entiendes el patr√≥n de input binding (find ‚Üí getValue ‚Üí subscribe), puedes construir cualquier input.\nUna vez que entiendes el patr√≥n de output (find ‚Üí renderValue), puedes renderizar cualquier cosa."
  },
  {
    "objectID": "index.html#qu√©-vamos-a-construir",
    "href": "index.html#qu√©-vamos-a-construir",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "¬øQu√© Vamos a Construir?",
    "text": "¬øQu√© Vamos a Construir?\nUn toggle de tres estados para filtrar tareas:\n\nTodas: Muestra todas las tareas\nActivas: Solo tareas pendientes\nCompletadas: Solo tareas terminadas\n\n\nEste componente demuestra que getValue() puede retornar cualquier tipo de dato, no solo booleanos."
  },
  {
    "objectID": "index.html#estructura-del-ejercicio",
    "href": "index.html#estructura-del-ejercicio",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "Estructura del Ejercicio",
    "text": "Estructura del Ejercicio\n01-input-starter/\n‚îú‚îÄ‚îÄ app.R                    # App de Shiny\n‚îú‚îÄ‚îÄ R/\n‚îÇ   ‚îî‚îÄ‚îÄ triStateInput.R      # Funciones R (completas)\n‚îî‚îÄ‚îÄ www/\n    ‚îú‚îÄ‚îÄ css/\n    ‚îÇ   ‚îî‚îÄ‚îÄ tristate.css     # Estilos (completos)\n    ‚îî‚îÄ‚îÄ js/\n        ‚îî‚îÄ‚îÄ tristate.js      # ¬°AQU√ç TRABAJAREMOS!"
  },
  {
    "objectID": "index.html#el-lado-r-ya-est√°-completo",
    "href": "index.html#el-lado-r-ya-est√°-completo",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "El Lado R Ya Est√° Completo",
    "text": "El Lado R Ya Est√° Completo\ntriStateInput &lt;- function(inputId, label, choices, selected = NULL) {\n  tagList(\n    triStateDependency(),\n    tags$div(\n      id = inputId,\n      class = \"tri-state-input\",\n      `data-selected` = selected,\n      tags$label(class = \"control-label\", label),\n      tags$div(class = \"tri-state-options\", ...)\n    )\n  )\n}"
  },
  {
    "objectID": "index.html#el-esqueleto-de-javascript",
    "href": "index.html#el-esqueleto-de-javascript",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "El Esqueleto de JavaScript",
    "text": "El Esqueleto de JavaScript\n\n\nwww/js/tristate.js\n\nvar triStateBinding = new Shiny.InputBinding();\n\n$.extend(triStateBinding, {\n  find: function(scope) {\n    // TU C√ìDIGO AQU√ç\n  },\n  getValue: function(el) {\n    // TU C√ìDIGO AQU√ç\n  },\n  subscribe: function(el, callback) {\n    // TU C√ìDIGO AQU√ç\n  },\n  // ... m√°s m√©todos\n});\n\nShiny.inputBindings.register(triStateBinding, 'workshop.triStateInput');"
  },
  {
    "objectID": "index.html#paso-1-implementar-find",
    "href": "index.html#paso-1-implementar-find",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "Paso 1: Implementar find()",
    "text": "Paso 1: Implementar find()\nEl m√©todo find() localiza todas las instancias del input en el DOM.\nfind: function(scope) {\n  return $(scope).find('.tri-state-input');\n}\n\n\n\n\n\n\nTip\n\n\nUsa selectores de clase (.clase) en lugar de ID para soportar m√∫ltiples instancias."
  },
  {
    "objectID": "index.html#paso-2-implementar-getvalue",
    "href": "index.html#paso-2-implementar-getvalue",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "Paso 2: Implementar getValue()",
    "text": "Paso 2: Implementar getValue()\nEl m√©todo getValue() extrae el valor actual del elemento.\ngetValue: function(el) {\n  return $(el).data('selected');\n}\n\n\n\n\n\n\nWarning\n\n\nError com√∫n: Olvidar el return. Sin √©l, el binding falla silenciosamente y R recibe NULL."
  },
  {
    "objectID": "index.html#checkpoint-1",
    "href": "index.html#checkpoint-1",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "Checkpoint 1",
    "text": "Checkpoint 1\nDespu√©s de implementar find() y getValue():\n\nSin errores de JavaScript en la consola\nEl cuadro ‚ÄúValor actual‚Äù muestra \"all\" (no NULL)\n\n# En la consola de R, deber√≠as ver:\ninput$task_filter\n# [1] \"all\""
  },
  {
    "objectID": "index.html#paso-3-implementar-subscribe",
    "href": "index.html#paso-3-implementar-subscribe",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "Paso 3: Implementar subscribe()",
    "text": "Paso 3: Implementar subscribe()\nEl m√©todo subscribe() configura los event listeners.\nsubscribe: function(el, callback) {\n  $(el).on('click.triStateBinding', '.tri-state-option', function(e) {\n    var value = $(this).data('value');\n    $(el).data('selected', value);\n\n    // Actualizar estado visual\n    $(el).find('.tri-state-option').removeClass('active');\n    $(this).addClass('active');\n\n    callback();\n  });\n}"
  },
  {
    "objectID": "index.html#namespacing-de-eventos",
    "href": "index.html#namespacing-de-eventos",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "Namespacing de Eventos",
    "text": "Namespacing de Eventos\n// ‚úÖ Correcto: usa namespace\n$(el).on('click.triStateBinding', handler);\n\n// ‚ùå Incorrecto: sin namespace\n$(el).on('click', handler);\n\n\n\n\n\n\nNote\n\n\nEl namespace (.triStateBinding) permite que unsubscribe() remueva solo nuestros handlers sin afectar otros."
  },
  {
    "objectID": "index.html#checkpoint-2",
    "href": "index.html#checkpoint-2",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "Checkpoint 2",
    "text": "Checkpoint 2\nDespu√©s de implementar subscribe():\n\nAl hacer clic en las opciones, cambia el valor en R\nLa tabla de tareas se filtra correctamente\nEl estado visual (bot√≥n activo) se actualiza"
  },
  {
    "objectID": "index.html#paso-4-implementar-setvalue-y-receivemessage",
    "href": "index.html#paso-4-implementar-setvalue-y-receivemessage",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "Paso 4: Implementar setValue() y receiveMessage()",
    "text": "Paso 4: Implementar setValue() y receiveMessage()\nPara que updateTriStateInput() funcione desde R:\nsetValue: function(el, value) {\n  $(el).data('selected', value);\n  $(el).find('.tri-state-option').removeClass('active');\n  $(el).find('.tri-state-option[data-value=\"' + value + '\"]').addClass('active');\n},\n\nreceiveMessage: function(el, data) {\n  if (data.hasOwnProperty('selected')) {\n    this.setValue(el, data.selected);\n    $(el).trigger('change');\n  }\n}"
  },
  {
    "objectID": "index.html#no-olvides-el-evento-change",
    "href": "index.html#no-olvides-el-evento-change",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "No Olvides el Evento Change",
    "text": "No Olvides el Evento Change\nreceiveMessage: function(el, data) {\n  if (data.hasOwnProperty('selected')) {\n    this.setValue(el, data.selected);\n    $(el).trigger('change');  // ¬°Importante!\n  }\n}\n\n\n\n\n\n\nWarning\n\n\nSin $(el).trigger('change'), la actualizaci√≥n no se propaga a las dependencias reactivas."
  },
  {
    "objectID": "index.html#tambi√©n-necesitamos-escuchar-change",
    "href": "index.html#tambi√©n-necesitamos-escuchar-change",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "Tambi√©n necesitamos escuchar ‚Äòchange‚Äô",
    "text": "Tambi√©n necesitamos escuchar ‚Äòchange‚Äô\nsubscribe: function(el, callback) {\n  $(el).on('click.triStateBinding', '.tri-state-option', function(e) {\n    // ... c√≥digo de click ...\n    callback();\n  });\n\n  // Para receiveMessage\n  $(el).on('change.triStateBinding', function(e) {\n    callback();\n  });\n}"
  },
  {
    "objectID": "index.html#checkpoint-3",
    "href": "index.html#checkpoint-3",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "Checkpoint 3",
    "text": "Checkpoint 3\nDespu√©s de implementar setValue() y receiveMessage():\n\nEl bot√≥n ‚ÄúRestablecer a ‚ÄòTodas‚Äô‚Äù funciona\nAl hacer clic, el toggle vuelve a ‚ÄúTodas‚Äù\nLa tabla muestra todas las tareas"
  },
  {
    "objectID": "index.html#soluci√≥n-completa-del-input-binding",
    "href": "index.html#soluci√≥n-completa-del-input-binding",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "Soluci√≥n Completa del Input Binding",
    "text": "Soluci√≥n Completa del Input Binding\nvar triStateBinding = new Shiny.InputBinding();\n\n$.extend(triStateBinding, {\n  find: function(scope) {\n    return $(scope).find('.tri-state-input');\n  },\n\n  getValue: function(el) {\n    return $(el).data('selected');\n  },\n\n  subscribe: function(el, callback) {\n    $(el).on('click.triStateBinding', '.tri-state-option', function(e) {\n      var value = $(this).data('value');\n      $(el).data('selected', value);\n      $(el).find('.tri-state-option').removeClass('active');\n      $(this).addClass('active');\n      callback();\n    });\n    $(el).on('change.triStateBinding', function(e) {\n      callback();\n    });\n  },\n\n  setValue: function(el, value) {\n    $(el).data('selected', value);\n    $(el).find('.tri-state-option').removeClass('active');\n    $(el).find('.tri-state-option[data-value=\"' + value + '\"]').addClass('active');\n  },\n\n  receiveMessage: function(el, data) {\n    if (data.hasOwnProperty('selected')) {\n      this.setValue(el, data.selected);\n      $(el).trigger('change');\n    }\n  }\n});\n\nShiny.inputBindings.register(triStateBinding, 'workshop.triStateInput');"
  },
  {
    "objectID": "index.html#extensi√≥n-rate-policy",
    "href": "index.html#extensi√≥n-rate-policy",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "Extensi√≥n: Rate Policy",
    "text": "Extensi√≥n: Rate Policy\nSi hay tiempo, a√±ade limitaci√≥n de frecuencia:\ngetRatePolicy: function() {\n  return { policy: 'debounce', delay: 250 };\n}\nPol√≠ticas disponibles:\n\ndirect: Env√≠a inmediatamente\ndebounce: Espera hasta que no haya nuevos valores\nthrottle: M√°ximo un env√≠o por per√≠odo"
  },
  {
    "objectID": "index.html#qu√©-vamos-a-construir-1",
    "href": "index.html#qu√©-vamos-a-construir-1",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "¬øQu√© Vamos a Construir?",
    "text": "¬øQu√© Vamos a Construir?\nUna tarjeta de estad√≠sticas que:\n\nMuestra un t√≠tulo y un valor num√©rico\nCambia de color seg√∫n umbrales (verde/amarillo/rojo)\nSe actualiza reactivamente desde R"
  },
  {
    "objectID": "index.html#estructura-del-ejercicio-1",
    "href": "index.html#estructura-del-ejercicio-1",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "Estructura del Ejercicio",
    "text": "Estructura del Ejercicio\n03-output-starter/\n‚îú‚îÄ‚îÄ app.R                    # App de Shiny\n‚îú‚îÄ‚îÄ R/\n‚îÇ   ‚îî‚îÄ‚îÄ statCard.R           # Funciones R (completas)\n‚îî‚îÄ‚îÄ www/\n    ‚îú‚îÄ‚îÄ css/\n    ‚îÇ   ‚îî‚îÄ‚îÄ statcard.css     # Estilos (completos)\n    ‚îî‚îÄ‚îÄ js/\n        ‚îî‚îÄ‚îÄ statcard.js      # ¬°AQU√ç TRABAJAREMOS!"
  },
  {
    "objectID": "index.html#el-lado-r-ya-est√°-completo-1",
    "href": "index.html#el-lado-r-ya-est√°-completo-1",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "El Lado R Ya Est√° Completo",
    "text": "El Lado R Ya Est√° Completo\nstatCardOutput &lt;- function(outputId, width = \"200px\") {\n  tagList(\n    statCardDependency(),\n    tags$div(\n      id = outputId,\n      class = \"stat-card\",\n      style = paste0(\"width: \", width, \";\"),\n      tags$div(class = \"stat-title\", \"Loading...\"),\n      tags$div(class = \"stat-value\", \"--\")\n    )\n  )\n}"
  },
  {
    "objectID": "index.html#la-funci√≥n-render-en-r",
    "href": "index.html#la-funci√≥n-render-en-r",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "La Funci√≥n Render en R",
    "text": "La Funci√≥n Render en R\nrenderStatCard &lt;- function(expr) {\n  func &lt;- shiny::quoToFunction(rlang::enquo0(expr))\n\n  shiny::createRenderFunction(\n    func,\n    transform = function(value, session, name, ...) {\n      list(\n        title = value$title,\n        value = value$value,\n        status = value$status\n      )\n    },\n    outputFunc = statCardOutput\n  )\n}"
  },
  {
    "objectID": "index.html#el-esqueleto-de-javascript-1",
    "href": "index.html#el-esqueleto-de-javascript-1",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "El Esqueleto de JavaScript",
    "text": "El Esqueleto de JavaScript\n\n\nwww/js/statcard.js\n\nvar statCardBinding = new Shiny.OutputBinding();\n\n$.extend(statCardBinding, {\n  find: function(scope) {\n    // TU C√ìDIGO AQU√ç\n  },\n  renderValue: function(el, data) {\n    // TU C√ìDIGO AQU√ç\n  }\n});\n\nShiny.outputBindings.register(statCardBinding, 'workshop.statCard');"
  },
  {
    "objectID": "index.html#paso-1-implementar-find-1",
    "href": "index.html#paso-1-implementar-find-1",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "Paso 1: Implementar find()",
    "text": "Paso 1: Implementar find()\nId√©ntico al patr√≥n de input bindings:\nfind: function(scope) {\n  return $(scope).find('.stat-card');\n}"
  },
  {
    "objectID": "index.html#paso-2-implementar-rendervalue",
    "href": "index.html#paso-2-implementar-rendervalue",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "Paso 2: Implementar renderValue()",
    "text": "Paso 2: Implementar renderValue()\nEste m√©todo recibe los datos de R y actualiza el DOM:\nrenderValue: function(el, data) {\n  // Actualizar t√≠tulo y valor\n  $(el).find('.stat-title').text(data.title);\n  $(el).find('.stat-value').text(data.value);\n\n  // Actualizar clase de estado\n  $(el).removeClass('status-good status-warning status-bad');\n  if (data.status) {\n    $(el).addClass('status-' + data.status);\n  }\n}"
  },
  {
    "objectID": "index.html#los-datos-llegan-como-json",
    "href": "index.html#los-datos-llegan-como-json",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "Los Datos Llegan como JSON",
    "text": "Los Datos Llegan como JSON\nEn R enviamos:\nlist(title = \"Puntuaci√≥n\", value = 75, status = \"warning\")\nEn JavaScript recibimos:\n{\n  title: \"Puntuaci√≥n\",\n  value: 75,\n  status: \"warning\"\n}"
  },
  {
    "objectID": "index.html#checkpoint-final",
    "href": "index.html#checkpoint-final",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "Checkpoint Final",
    "text": "Checkpoint Final\nDespu√©s de implementar ambos m√©todos:\n\nLa tarjeta muestra el t√≠tulo y el valor\nAl mover el slider, el valor se actualiza\nEl color cambia seg√∫n los umbrales:\n\nüü¢ Verde: 80-100\nüü° Amarillo: 50-79\nüî¥ Rojo: 0-49"
  },
  {
    "objectID": "index.html#soluci√≥n-completa-del-output-binding",
    "href": "index.html#soluci√≥n-completa-del-output-binding",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "Soluci√≥n Completa del Output Binding",
    "text": "Soluci√≥n Completa del Output Binding\nvar statCardBinding = new Shiny.OutputBinding();\n\n$.extend(statCardBinding, {\n  find: function(scope) {\n    return $(scope).find('.stat-card');\n  },\n\n  renderValue: function(el, data) {\n    $(el).find('.stat-title').text(data.title);\n    $(el).find('.stat-value').text(data.value);\n\n    $(el).removeClass('status-good status-warning status-bad');\n    if (data.status) {\n      $(el).addClass('status-' + data.status);\n    }\n  }\n});\n\nShiny.outputBindings.register(statCardBinding, 'workshop.statCard');"
  },
  {
    "objectID": "index.html#recapitulaci√≥n",
    "href": "index.html#recapitulaci√≥n",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "Recapitulaci√≥n",
    "text": "Recapitulaci√≥n\n\n\nInput Bindings\n\nfind() - Localizar elementos\ngetValue() - Extraer valor\nsubscribe() - Escuchar eventos\nsetValue() - Establecer valor\nreceiveMessage() - Recibir de R\n\n\nOutput Bindings\n\nfind() - Localizar elementos\nrenderValue() - Renderizar datos\n\n(¬°M√°s simple!)"
  },
  {
    "objectID": "index.html#el-patr√≥n-escala",
    "href": "index.html#el-patr√≥n-escala",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "El Patr√≥n Escala",
    "text": "El Patr√≥n Escala\nEstos patrones son la base de paquetes como:\n\nshinyWidgets: Decenas de inputs personalizados de producci√≥n\nhtmlwidgets: Framework para D3.js y visualizaciones\nshiny.react: Componentes React en Shiny\nplotly, leaflet, DT: Widgets interactivos"
  },
  {
    "objectID": "index.html#recursos-para-profundizar",
    "href": "index.html#recursos-para-profundizar",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "Recursos para Profundizar",
    "text": "Recursos para Profundizar\n\n\n\n\n\n\n\nRecurso\nMejor para\n\n\n\n\nOutstanding User Interfaces with Shiny (Granjon)\nInternos de bindings\n\n\nJavaScript for R (Coene)\nFundamentos de JS en contexto R\n\n\nDocumentaci√≥n de htmlwidgets\nOutputs de visualizaci√≥n D3.js\n\n\nposit-dev/shiny-bindings\nPatrones emergentes, React"
  },
  {
    "objectID": "index.html#referencias-clave",
    "href": "index.html#referencias-clave",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "Referencias Clave",
    "text": "Referencias Clave\n\nPosit. ‚ÄúHow to Create Custom Input Bindings.‚Äù 2024. https://shiny.posit.co/r/articles/build/js-custom-input/\nPosit. ‚ÄúBuild Custom Output Objects.‚Äù 2024. https://shiny.posit.co/r/articles/build/building-outputs/\nGranjon, David. Outstanding User Interfaces with Shiny. Chapman and Hall/CRC, 2022. https://unleash-shiny.rinterface.com/"
  },
  {
    "objectID": "index.html#soluci√≥n-de-problemas-comunes",
    "href": "index.html#soluci√≥n-de-problemas-comunes",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "Soluci√≥n de Problemas Comunes",
    "text": "Soluci√≥n de Problemas Comunes\n\n\n\nProblema\nSoluci√≥n\n\n\n\n\n‚ÄúLa app no corre‚Äù\nVerificar directorio de trabajo\n\n\n‚ÄúLos cambios no aparecen‚Äù\nHard refresh (Ctrl+Shift+R)\n\n\n‚ÄúError de JavaScript en consola‚Äù\nRevisar comas y punto y coma\n\n\n‚ÄúEl valor es undefined en R‚Äù\nVerificar return en getValue()"
  },
  {
    "objectID": "index.html#gracias",
    "href": "index.html#gracias",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "¬°Gracias!",
    "text": "¬°Gracias!\n\n¬°Han construido un input y un output personalizados desde cero!\n\n\nEl patr√≥n siempre es el mismo:\nR genera HTML ‚Üí JavaScript maneja comportamiento ‚Üí WebSocket los conecta\nTodo lo dem√°s son variaciones de este tema."
  },
  {
    "objectID": "index.html#contacto-y-materiales",
    "href": "index.html#contacto-y-materiales",
    "title": "Creando Inputs y Outputs Personalizados para Shiny",
    "section": "Contacto y Materiales",
    "text": "Contacto y Materiales\n\n\nRepositorio\nTodo el c√≥digo est√° disponible en:\ngithub.com/‚Ä¶\n\nPreguntas\n¬øPreguntas ahora o despu√©s?\ncorreo@ejemplo.com"
  },
  {
    "objectID": "workshop-outline.html",
    "href": "workshop-outline.html",
    "title": "Workshop Outline: Building Custom Shiny Inputs and Outputs",
    "section": "",
    "text": "Title: Beyond Built-in Widgets: Creating Custom Shiny Inputs and Outputs\nDuration: 90 minutes\nParticipants: ~15 intermediate R/Shiny users\nFormat: Virtual, hands-on\nPrerequisites:\n\nIntermediate R experience\nComfortable building basic Shiny apps (understands ui, server, reactivity)\nMinimal JavaScript/CSS experience expected (starter code is heavily commented)\nRepository cloned and dependencies installed before the session\n\nLearning objectives:\n\nUnderstand how Shiny‚Äôs JavaScript binding system connects browser and R server\nBuild a functional custom input binding (multi-state toggle button)\nBuild a functional custom output binding (dynamic stat card with conditional styling)\nKnow where to find resources for more advanced implementations\n\n\n\n\n\n\n\n\nTime\nSegment\nDuration\n\n\n\n\n0:00‚Äì0:05\nWelcome and orientation\n5 min\n\n\n0:05‚Äì0:15\nConceptual foundation: How bindings work\n10 min\n\n\n0:15‚Äì0:55\nHands-on 1: Custom input binding\n40 min\n\n\n0:55‚Äì1:00\nShort break\n5 min\n\n\n1:00‚Äì1:20\nHands-on 2: Custom output binding\n20 min\n\n\n1:20‚Äì1:30\nWrap-up and next steps\n10 min\n\n\n\n\n\n\n\n\n\nContent:\n\nConfirm everyone has the repo cloned and can run the starter app\nQuick tour of repository structure\nOverview of what we‚Äôre building today (show finished demos)\n\nMaterials:\n\nRepo README with setup verification checklist\nTwo 30-second demo GIFs showing the finished input and output\n\nInstructor script:\n\n‚ÄúWelcome everyone! Before we dive in, let‚Äôs make sure your environment is ready. Open the 00-demo-finished/app.R file and click Run App. You should see a toggle button and a stat card. Thumbs up in chat if you see it working.‚Äù\n\n\n\n\n\nContent:\n\nThe WebSocket connection between browser and R (brief, conceptual)\nTwo registries: Shiny.inputBindings and Shiny.outputBindings\nAnatomy of a binding: R function generates HTML ‚Üí JavaScript class handles behavior ‚Üí messages flow both directions\nThe three essential input binding methods: find(), getValue(), subscribe()\nThe two essential output binding methods: find(), renderValue()\n\nDelivery:\n\nAnnotated diagram showing the communication flow\nSide-by-side comparison: built-in selectInput code vs.¬†what we‚Äôll build\n\nKey talking points:\n\nShiny uses WebSockets for real-time, bidirectional communication between the R server and the JavaScript client. When your app loads, a persistent connection is established that allows continuous two-way messaging.\nAll bindings live in registries. When Shiny initializes, it calls Shiny.bindAll() to scan the DOM and associate each matching element with its appropriate binding. The registries use a priority system‚Äîhigher numbers mean higher priority‚Äîwhich lets you override built-in bindings if needed.\nThe pattern is consistent. Once you understand the input binding pattern (find ‚Üí getValue ‚Üí subscribe), you can build any input. Once you understand the output pattern (find ‚Üí renderValue), you can render anything.\n\nInstructor note: Keep this brisk‚Äîaim for 8 minutes of content, 2 minutes for questions. The goal is a mental model, not deep understanding. That comes from building.\nKey references:\n\nPosit. ‚ÄúHow to Create Custom Input Bindings.‚Äù 2024. https://shiny.posit.co/r/articles/build/js-custom-input/\nGranjon, David. Outstanding User Interfaces with Shiny. Chapman and Hall/CRC, 2022. Chapter 6.\n\n\n\n\n\nWhat participants build:\nA toggle button that cycles through three states (e.g., ‚ÄúAll / Active / Completed‚Äù for a task filter). More interesting than a binary toggle, demonstrates that inputs can return any value type.\nWhy this component:\n\nMore impressive than a simple on/off toggle\nDemonstrates that getValue() can return any data type\nRequires handling click events and cycling through states\nNatural use case (filtering) makes the value immediately understandable\n\n\n\n\n\n\n\n\n\n\nTime\nActivity\n\n\n\n\n0‚Äì8 min\nWalkthrough of starter code (R UI function + JS skeleton)\n\n\n8‚Äì20 min\nGuided coding: implement find() and getValue()\n\n\n20‚Äì28 min\nGuided coding: implement subscribe() with click handler\n\n\n28‚Äì35 min\nGuided coding: implement receiveMessage() for update function\n\n\n35‚Äì40 min\nTest it: connect to a reactive output, verify round-trip\n\n\n\n\n\n\nR function triStateInput(inputId, label, choices, selected):\n\nComplete HTML structure using tags$\nAttached CSS dependency via htmltools::htmlDependency()\nData attributes storing choices and current selection\n\nCSS file tristate.css:\n\nFully written styling for the three-state visual appearance\nActive state highlighting\nHover effects\n\nJS file tristate.js:\n\nBinding skeleton with $.extend(myBinding, { ... })\nDetailed comments explaining each method‚Äôs purpose\nPlaceholder // YOUR CODE HERE markers\n\n\n\n\n\nfind(scope) ‚Äî The jQuery selector to locate all instances\nfind: function(scope) {\n  return $(scope).find('.tri-state-input');\n}\ngetValue(el) ‚Äî Extract the current state from a data attribute\ngetValue: function(el) {\n  return $(el).data('selected');\n}\nsubscribe(el, callback) ‚Äî Click handler that cycles states\nsubscribe: function(el, callback) {\n  $(el).on('click.triStateBinding', '.tri-state-option', function(e) {\n    var value = $(this).data('value');\n    $(el).data('selected', value);\n    // Update visual state\n    $(el).find('.tri-state-option').removeClass('active');\n    $(this).addClass('active');\n    callback();\n  });\n}\nsetValue(el, value) and receiveMessage(el, data) ‚Äî For the update function\nsetValue: function(el, value) {\n  $(el).data('selected', value);\n  $(el).find('.tri-state-option').removeClass('active');\n  $(el).find('.tri-state-option[data-value=\"' + value + '\"]').addClass('active');\n},\nreceiveMessage: function(el, data) {\n  if (data.hasOwnProperty('selected')) {\n    this.setValue(el, data.selected);\n    $(el).trigger('change');\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\nAfter‚Ä¶\nVerification\n\n\n\n\ngetValue()\nInstructor shows how to verify value in R console with input$x\n\n\nsubscribe()\nClicking should update input$x reactively\n\n\nreceiveMessage()\nupdateTriStateInput() should work from server\n\n\n\n\n\n\n\nForgetting to return a value from getValue() ‚Äî The binding fails silently\nNot using event namespacing ‚Äî Use click.triStateBinding so unsubscribe() can cleanly remove handlers\nForgetting to trigger change event in receiveMessage() ‚Äî The update won‚Äôt propagate to other reactive dependencies\n\n\n\n\nAdd getRatePolicy() to debounce rapid clicks:\ngetRatePolicy: function() {\n  return { policy: 'debounce', delay: 250 };\n}\nKey references:\n\nPosit. ‚ÄúHow to Create Custom Input Bindings.‚Äù 2024. https://shiny.posit.co/r/articles/build/js-custom-input/\nCoene, John. JavaScript for R. Chapman and Hall/CRC, 2021. Chapters 6‚Äì7.\n\n\n\n\n\n\nEncourage participants to stand, stretch. Instructor available for quick troubleshooting.\nInstructor note: Use this time to scan chat for unresolved questions. If multiple people are stuck at the same point, address it briefly when reconvening.\n\n\n\n\nWhat participants build:\nA stat card that displays a metric value with a title, and changes background color based on thresholds (e.g., green/yellow/red for KPI status). Demonstrates that outputs can receive structured data and apply conditional rendering.\nWhy this component:\n\nVisually satisfying result\nShows that renderValue() receives arbitrary R data (as JSON)\nConditional styling demonstrates real-world use case\nSimpler than input binding‚Äîgood for reinforcing the pattern quickly\n\n\n\n\n\n\n\n\n\n\nTime\nActivity\n\n\n\n\n0‚Äì5 min\nWalkthrough of starter code (R UI + render function + JS)\n\n\n5‚Äì15 min\nGuided coding: implement find() and renderValue()\n\n\n15‚Äì20 min\nTest and extend: add threshold-based CSS class\n\n\n\n\n\n\nR function statCardOutput(outputId, width):\n\nComplete HTML structure with placeholder elements for title and value\nCSS class stat-card for JavaScript binding to find\n\nR function renderStatCard(expr):\n\nUses exprToFunction() pattern (fully written)\nReturns a list with title, value, and status fields\n\nCSS file statcard.css:\n\nCard styling (shadow, padding, typography)\nThree color classes: .status-good, .status-warning, .status-bad\n\nJS file statcard.js:\n\nBinding skeleton with comments\nPlaceholder markers for participant code\n\n\n\n\n\nfind(scope) ‚Äî Locate stat card elements\nfind: function(scope) {\n  return $(scope).find('.stat-card');\n}\nrenderValue(el, data) ‚Äî Update DOM with received data\nrenderValue: function(el, data) {\n  // Set the title and value text\n  $(el).find('.stat-title').text(data.title);\n  $(el).find('.stat-value').text(data.value);\n\n  // Remove any existing status class and add the new one\n  $(el).removeClass('status-good status-warning status-bad');\n  if (data.status) {\n    $(el).addClass('status-' + data.status);\n  }\n}\n\n\n\n\nIn app.R, the server already has:\noutput$kpi_card &lt;- renderStatCard({\n  value &lt;- input$metric_slider\n  status &lt;- case_when(\n    value &gt;= 80 ~ \"good\",\n    value &gt;= 50 ~ \"warning\",\n    TRUE ~ \"bad\"\n  )\n  list(title = \"Performance Score\", value = value, status = status)\n})\nParticipants adjust the slider and watch the card update in real-time with color changes.\nKey references:\n\nPosit. ‚ÄúBuild Custom Output Objects.‚Äù 2024. https://shiny.posit.co/r/articles/build/building-outputs/\nGranjon, David. Outstanding User Interfaces with Shiny. Chapman and Hall/CRC, 2022. Chapter 7.\n\n\n\n\n\n\nContent:\n\nRecap the pattern ‚Äî The binding structure is consistent. Once you‚Äôve built one input binding, you can build any input. Same for outputs.\nShow how these patterns scale ‚Äî Brief mention of:\n\nshinyWidgets ‚Äî Dozens of production-quality inputs built with these exact patterns\nhtmlwidgets ‚Äî Framework for D3.js and other visualization libraries\nshiny.react ‚Äî React components in Shiny using similar binding concepts\n\nResources for going further:\n\n\n\n\n\n\n\nResource\nBest for\n\n\n\n\nOutstanding User Interfaces with Shiny (Granjon)\nDeep dives into binding internals\n\n\nJavaScript for R (Coene)\nJS fundamentals in R context\n\n\nhtmlwidgets documentation\nD3.js and visualization outputs\n\n\nposit-dev/shiny-bindings repo\nEmerging patterns, React integration\n\n\n\nQ&A ‚Äî Open floor for questions\n\nHandouts to share:\n\nOne-page binding method reference card (PDF)\nAnnotated bibliography with URLs (Markdown)\nLink to workshop repository with all solutions\n\nClosing script:\n\n‚ÄúYou‚Äôve now built a custom input and a custom output from scratch. The key insight is that the pattern is always the same: R generates HTML, JavaScript handles behavior, and WebSocket messages connect them. Everything else is just variations on this theme. The resources in the handout will take you deeper when you‚Äôre ready. Thanks for joining‚Äîhappy binding building!‚Äù\n\n\n\n\n\n\nshiny-custom-bindings-workshop/\n‚îú‚îÄ‚îÄ README.md                     # Setup instructions, prerequisites\n‚îú‚îÄ‚îÄ 00-demo-finished/\n‚îÇ   ‚îî‚îÄ‚îÄ app.R                     # Finished app showing both components\n‚îú‚îÄ‚îÄ 01-input-starter/\n‚îÇ   ‚îú‚îÄ‚îÄ app.R                     # Starter app with placeholder\n‚îÇ   ‚îú‚îÄ‚îÄ R/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ triStateInput.R       # UI + update functions (complete)\n‚îÇ   ‚îî‚îÄ‚îÄ www/\n‚îÇ       ‚îú‚îÄ‚îÄ css/\n‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ tristate.css      # Styling (complete)\n‚îÇ       ‚îî‚îÄ‚îÄ js/\n‚îÇ           ‚îî‚îÄ‚îÄ tristate.js       # Binding skeleton (to complete)\n‚îú‚îÄ‚îÄ 02-input-solution/\n‚îÇ   ‚îî‚îÄ‚îÄ ...                       # Complete solution for reference\n‚îú‚îÄ‚îÄ 03-output-starter/\n‚îÇ   ‚îú‚îÄ‚îÄ app.R\n‚îÇ   ‚îú‚îÄ‚îÄ R/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ statCard.R            # UI + render functions (complete)\n‚îÇ   ‚îî‚îÄ‚îÄ www/\n‚îÇ       ‚îú‚îÄ‚îÄ css/\n‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ statcard.css      # Styling (complete)\n‚îÇ       ‚îî‚îÄ‚îÄ js/\n‚îÇ           ‚îî‚îÄ‚îÄ statcard.js       # Binding skeleton (to complete)\n‚îú‚îÄ‚îÄ 04-output-solution/\n‚îÇ   ‚îî‚îÄ‚îÄ ...\n‚îî‚îÄ‚îÄ reference/\n    ‚îú‚îÄ‚îÄ binding-cheatsheet.pdf\n    ‚îî‚îÄ‚îÄ resources.md\n\n\n\n\n\n\n\nScreen sharing: Use large font size in IDE (14pt minimum). Consider a dark theme for better visibility on varied monitors.\nBreakout rooms: If troubleshooting takes more than 30 seconds for one participant, offer to move them to a breakout room with a TA.\nChat monitoring: Have a co-instructor or TA dedicated to watching chat for questions and flagging urgent issues.\nSolution files: Emphasize that participants who fall behind can copy from the solution folder to catch up. The learning happens from seeing the pattern, not just typing.\n\n\n\n\n\nThe 40-minute input segment has ~5 minutes flexibility\nIf running long: abbreviate receiveMessage() walkthrough (participants can reference solution)\nIf running fast: add the getRatePolicy() extension\nThe output segment is designed to be faster; if the input runs over by 5 minutes, the output can compress to 15 minutes\n\n\n\n\n\n\n\n\n\n\n\nIssue\nSolution\n\n\n\n\n‚ÄúApp won‚Äôt run‚Äù\nCheck working directory is set to project root\n\n\n‚ÄúChanges don‚Äôt appear‚Äù\nHard refresh browser (Ctrl+Shift+R / Cmd+Shift+R)\n\n\n‚ÄúJavaScript error in console‚Äù\nCheck for missing commas, semicolons in binding object\n\n\n‚ÄúInput value is undefined in R‚Äù\nVerify getValue() has explicit return statement\n\n\n\n\n\n\n\nEnsure all code comments are screen-reader friendly (no ASCII art)\nProvide transcript of the finished demo in README\nUse high-contrast colors in diagrams\nShare slides/materials in advance for participants using assistive technology\n\n\n\n\n\n\n\n\n\nRepository published and tested on clean machine\nREADME with setup verification steps\nDemo GIFs created for finished components\nSlides for conceptual section (10 min)\nBinding cheatsheet PDF\nResources markdown file\nCalendar invite with repo link and setup instructions sent\n\n\n\n\n\nBackup of all materials on local machine\nScreen sharing tested\nBreakout rooms configured\nChat monitoring plan confirmed with TA\nPost-workshop survey link ready\n\n\n\n\n\n\n\n\nPosit Software, PBC. ‚ÄúHow to Create Custom Input Bindings.‚Äù 2024. https://shiny.posit.co/r/articles/build/js-custom-input/\nPosit Software, PBC. ‚ÄúBuild Custom Output Objects.‚Äù 2024. https://shiny.posit.co/r/articles/build/building-outputs/\nPosit Software, PBC. ‚ÄúCommunicating with Shiny via JavaScript.‚Äù 2024. https://shiny.posit.co/r/articles/build/communicating-with-js/\nGranjon, David. Outstanding User Interfaces with Shiny. Chapman and Hall/CRC, 2022. https://unleash-shiny.rinterface.com/\nCoene, John. JavaScript for R. Chapman and Hall/CRC, 2021. https://javascript-for-r.com/\n\n\n\nWickham, Hadley. Mastering Shiny: Build Interactive Apps, Reports, and Dashboards Powered by R. O‚ÄôReilly Media, 2021. https://mastering-shiny.org/\nFay, Colin, S√©bastien Rochette, Vincent Guyader, and Cervan Girard. Engineering Production-Grade Shiny Apps. Chapman and Hall/CRC, 2021. https://engineering-shiny.org/\nhtmlwidgets documentation. ‚ÄúCreating a Widget.‚Äù 2024. https://www.htmlwidgets.org/develop_intro.html\nPosit Software, PBC. ‚ÄúShiny Bindings: JavaScript Packages for Custom Bindings.‚Äù GitHub, 2024. https://github.com/posit-dev/shiny-bindings\n\n\n\nshinyWidgets: Custom Inputs Widgets for Shiny. Perrier, Victor, Fanny Meyer, and David Granjon. https://CRAN.R-project.org/package=shinyWidgets\nshinyjs: Easily Improve the User Experience of Your Shiny Apps in Seconds. Attali, Dean. https://CRAN.R-project.org/package=shinyjs\nhtmlwidgets: HTML Widgets for R. Vaidyanathan, Ramnath, et al.¬†https://CRAN.R-project.org/package=htmlwidgets\n\n\n\n\n\nFor use with pandoc or quarto when producing formal documentation:\n@online{posit2024custominput,\n  author = {{Posit Software, PBC}},\n  title = {How to Create Custom Input Bindings},\n  year = {2024},\n  url = {https://shiny.posit.co/r/articles/build/js-custom-input/},\n  note = {Accessed: 2025-11-26}\n}\n\n@online{posit2024buildingoutputs,\n  author = {{Posit Software, PBC}},\n  title = {Build Custom Output Objects},\n  year = {2024},\n  url = {https://shiny.posit.co/r/articles/build/building-outputs/},\n  note = {Accessed: 2025-11-26}\n}\n\n@online{posit2024communicatingjs,\n  author = {{Posit Software, PBC}},\n  title = {Communicating with Shiny via JavaScript},\n  year = {2024},\n  url = {https://shiny.posit.co/r/articles/build/communicating-with-js/},\n  note = {Accessed: 2025-11-26}\n}\n\n@book{granjon2022outstanding,\n  author = {Granjon, David},\n  title = {Outstanding User Interfaces with Shiny},\n  year = {2022},\n  publisher = {Chapman and Hall/CRC},\n  series = {The R Series},\n  isbn = {978-0-367-64365-2},\n  doi = {10.1201/9781003124924},\n  url = {https://unleash-shiny.rinterface.com/},\n  note = {Accessed: 2025-11-26}\n}\n\n@book{coene2021javascript,\n  author = {Coene, John},\n  title = {JavaScript for R},\n  year = {2021},\n  publisher = {Chapman and Hall/CRC},\n  series = {The R Series},\n  isbn = {978-0-367-68063-3},\n  url = {https://javascript-for-r.com/},\n  note = {Accessed: 2025-11-26}\n}\n\n@book{wickham2021mastering,\n  author = {Wickham, Hadley},\n  title = {Mastering Shiny: Build Interactive Apps, Reports, and Dashboards Powered by R},\n  year = {2021},\n  publisher = {O'Reilly Media},\n  isbn = {978-1-492-04738-4},\n  url = {https://mastering-shiny.org/},\n  note = {Accessed: 2025-11-26}\n}\n\n@book{fay2021engineering,\n  author = {Fay, Colin and Rochette, S√©bastien and Guyader, Vincent and Girard, Cervan},\n  title = {Engineering Production-Grade Shiny Apps},\n  year = {2021},\n  publisher = {Chapman and Hall/CRC},\n  series = {The R Series},\n  isbn = {978-0-367-46602-2},\n  doi = {10.1201/9781003029878},\n  url = {https://engineering-shiny.org/},\n  note = {Accessed: 2025-11-26}\n}\n\n@manual{htmlwidgets2024,\n  title = {htmlwidgets: HTML Widgets for R},\n  author = {Vaidyanathan, Ramnath and Xie, Yihui and Allaire, JJ and Cheng, Joe and Sievert, Carson and Russell, Kenton},\n  year = {2024},\n  note = {R package version 1.6.4},\n  url = {https://CRAN.R-project.org/package=htmlwidgets}\n}\n\n@online{htmlwidgets_develop,\n  author = {Vaidyanathan, Ramnath and Xie, Yihui and Allaire, JJ and Cheng, Joe and Sievert, Carson},\n  title = {Creating a Widget},\n  year = {2024},\n  url = {https://www.htmlwidgets.org/develop_intro.html},\n  note = {Accessed: 2025-11-26}\n}\n\n@manual{shinyWidgets2024,\n  title = {shinyWidgets: Custom Inputs Widgets for Shiny},\n  author = {Perrier, Victor and Meyer, Fanny and Granjon, David},\n  year = {2024},\n  note = {R package version 0.8.7},\n  url = {https://CRAN.R-project.org/package=shinyWidgets}\n}\n\n@manual{shinyjs2024,\n  title = {shinyjs: Easily Improve the User Experience of Your Shiny Apps in Seconds},\n  author = {Attali, Dean},\n  year = {2024},\n  url = {https://CRAN.R-project.org/package=shinyjs}\n}\n\n@misc{shinybindings_github,\n  author = {{Posit Software, PBC}},\n  title = {Shiny Bindings: JavaScript Packages for Custom Bindings},\n  year = {2024},\n  publisher = {GitHub},\n  url = {https://github.com/posit-dev/shiny-bindings},\n  note = {Accessed: 2025-11-26}\n}"
  },
  {
    "objectID": "workshop-outline.html#overview",
    "href": "workshop-outline.html#overview",
    "title": "Workshop Outline: Building Custom Shiny Inputs and Outputs",
    "section": "",
    "text": "Title: Beyond Built-in Widgets: Creating Custom Shiny Inputs and Outputs\nDuration: 90 minutes\nParticipants: ~15 intermediate R/Shiny users\nFormat: Virtual, hands-on\nPrerequisites:\n\nIntermediate R experience\nComfortable building basic Shiny apps (understands ui, server, reactivity)\nMinimal JavaScript/CSS experience expected (starter code is heavily commented)\nRepository cloned and dependencies installed before the session\n\nLearning objectives:\n\nUnderstand how Shiny‚Äôs JavaScript binding system connects browser and R server\nBuild a functional custom input binding (multi-state toggle button)\nBuild a functional custom output binding (dynamic stat card with conditional styling)\nKnow where to find resources for more advanced implementations"
  },
  {
    "objectID": "workshop-outline.html#schedule",
    "href": "workshop-outline.html#schedule",
    "title": "Workshop Outline: Building Custom Shiny Inputs and Outputs",
    "section": "",
    "text": "Time\nSegment\nDuration\n\n\n\n\n0:00‚Äì0:05\nWelcome and orientation\n5 min\n\n\n0:05‚Äì0:15\nConceptual foundation: How bindings work\n10 min\n\n\n0:15‚Äì0:55\nHands-on 1: Custom input binding\n40 min\n\n\n0:55‚Äì1:00\nShort break\n5 min\n\n\n1:00‚Äì1:20\nHands-on 2: Custom output binding\n20 min\n\n\n1:20‚Äì1:30\nWrap-up and next steps\n10 min"
  },
  {
    "objectID": "workshop-outline.html#segment-details",
    "href": "workshop-outline.html#segment-details",
    "title": "Workshop Outline: Building Custom Shiny Inputs and Outputs",
    "section": "",
    "text": "Content:\n\nConfirm everyone has the repo cloned and can run the starter app\nQuick tour of repository structure\nOverview of what we‚Äôre building today (show finished demos)\n\nMaterials:\n\nRepo README with setup verification checklist\nTwo 30-second demo GIFs showing the finished input and output\n\nInstructor script:\n\n‚ÄúWelcome everyone! Before we dive in, let‚Äôs make sure your environment is ready. Open the 00-demo-finished/app.R file and click Run App. You should see a toggle button and a stat card. Thumbs up in chat if you see it working.‚Äù\n\n\n\n\n\nContent:\n\nThe WebSocket connection between browser and R (brief, conceptual)\nTwo registries: Shiny.inputBindings and Shiny.outputBindings\nAnatomy of a binding: R function generates HTML ‚Üí JavaScript class handles behavior ‚Üí messages flow both directions\nThe three essential input binding methods: find(), getValue(), subscribe()\nThe two essential output binding methods: find(), renderValue()\n\nDelivery:\n\nAnnotated diagram showing the communication flow\nSide-by-side comparison: built-in selectInput code vs.¬†what we‚Äôll build\n\nKey talking points:\n\nShiny uses WebSockets for real-time, bidirectional communication between the R server and the JavaScript client. When your app loads, a persistent connection is established that allows continuous two-way messaging.\nAll bindings live in registries. When Shiny initializes, it calls Shiny.bindAll() to scan the DOM and associate each matching element with its appropriate binding. The registries use a priority system‚Äîhigher numbers mean higher priority‚Äîwhich lets you override built-in bindings if needed.\nThe pattern is consistent. Once you understand the input binding pattern (find ‚Üí getValue ‚Üí subscribe), you can build any input. Once you understand the output pattern (find ‚Üí renderValue), you can render anything.\n\nInstructor note: Keep this brisk‚Äîaim for 8 minutes of content, 2 minutes for questions. The goal is a mental model, not deep understanding. That comes from building.\nKey references:\n\nPosit. ‚ÄúHow to Create Custom Input Bindings.‚Äù 2024. https://shiny.posit.co/r/articles/build/js-custom-input/\nGranjon, David. Outstanding User Interfaces with Shiny. Chapman and Hall/CRC, 2022. Chapter 6.\n\n\n\n\n\nWhat participants build:\nA toggle button that cycles through three states (e.g., ‚ÄúAll / Active / Completed‚Äù for a task filter). More interesting than a binary toggle, demonstrates that inputs can return any value type.\nWhy this component:\n\nMore impressive than a simple on/off toggle\nDemonstrates that getValue() can return any data type\nRequires handling click events and cycling through states\nNatural use case (filtering) makes the value immediately understandable\n\n\n\n\n\n\n\n\n\n\nTime\nActivity\n\n\n\n\n0‚Äì8 min\nWalkthrough of starter code (R UI function + JS skeleton)\n\n\n8‚Äì20 min\nGuided coding: implement find() and getValue()\n\n\n20‚Äì28 min\nGuided coding: implement subscribe() with click handler\n\n\n28‚Äì35 min\nGuided coding: implement receiveMessage() for update function\n\n\n35‚Äì40 min\nTest it: connect to a reactive output, verify round-trip\n\n\n\n\n\n\nR function triStateInput(inputId, label, choices, selected):\n\nComplete HTML structure using tags$\nAttached CSS dependency via htmltools::htmlDependency()\nData attributes storing choices and current selection\n\nCSS file tristate.css:\n\nFully written styling for the three-state visual appearance\nActive state highlighting\nHover effects\n\nJS file tristate.js:\n\nBinding skeleton with $.extend(myBinding, { ... })\nDetailed comments explaining each method‚Äôs purpose\nPlaceholder // YOUR CODE HERE markers\n\n\n\n\n\nfind(scope) ‚Äî The jQuery selector to locate all instances\nfind: function(scope) {\n  return $(scope).find('.tri-state-input');\n}\ngetValue(el) ‚Äî Extract the current state from a data attribute\ngetValue: function(el) {\n  return $(el).data('selected');\n}\nsubscribe(el, callback) ‚Äî Click handler that cycles states\nsubscribe: function(el, callback) {\n  $(el).on('click.triStateBinding', '.tri-state-option', function(e) {\n    var value = $(this).data('value');\n    $(el).data('selected', value);\n    // Update visual state\n    $(el).find('.tri-state-option').removeClass('active');\n    $(this).addClass('active');\n    callback();\n  });\n}\nsetValue(el, value) and receiveMessage(el, data) ‚Äî For the update function\nsetValue: function(el, value) {\n  $(el).data('selected', value);\n  $(el).find('.tri-state-option').removeClass('active');\n  $(el).find('.tri-state-option[data-value=\"' + value + '\"]').addClass('active');\n},\nreceiveMessage: function(el, data) {\n  if (data.hasOwnProperty('selected')) {\n    this.setValue(el, data.selected);\n    $(el).trigger('change');\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\nAfter‚Ä¶\nVerification\n\n\n\n\ngetValue()\nInstructor shows how to verify value in R console with input$x\n\n\nsubscribe()\nClicking should update input$x reactively\n\n\nreceiveMessage()\nupdateTriStateInput() should work from server\n\n\n\n\n\n\n\nForgetting to return a value from getValue() ‚Äî The binding fails silently\nNot using event namespacing ‚Äî Use click.triStateBinding so unsubscribe() can cleanly remove handlers\nForgetting to trigger change event in receiveMessage() ‚Äî The update won‚Äôt propagate to other reactive dependencies\n\n\n\n\nAdd getRatePolicy() to debounce rapid clicks:\ngetRatePolicy: function() {\n  return { policy: 'debounce', delay: 250 };\n}\nKey references:\n\nPosit. ‚ÄúHow to Create Custom Input Bindings.‚Äù 2024. https://shiny.posit.co/r/articles/build/js-custom-input/\nCoene, John. JavaScript for R. Chapman and Hall/CRC, 2021. Chapters 6‚Äì7.\n\n\n\n\n\n\nEncourage participants to stand, stretch. Instructor available for quick troubleshooting.\nInstructor note: Use this time to scan chat for unresolved questions. If multiple people are stuck at the same point, address it briefly when reconvening.\n\n\n\n\nWhat participants build:\nA stat card that displays a metric value with a title, and changes background color based on thresholds (e.g., green/yellow/red for KPI status). Demonstrates that outputs can receive structured data and apply conditional rendering.\nWhy this component:\n\nVisually satisfying result\nShows that renderValue() receives arbitrary R data (as JSON)\nConditional styling demonstrates real-world use case\nSimpler than input binding‚Äîgood for reinforcing the pattern quickly\n\n\n\n\n\n\n\n\n\n\nTime\nActivity\n\n\n\n\n0‚Äì5 min\nWalkthrough of starter code (R UI + render function + JS)\n\n\n5‚Äì15 min\nGuided coding: implement find() and renderValue()\n\n\n15‚Äì20 min\nTest and extend: add threshold-based CSS class\n\n\n\n\n\n\nR function statCardOutput(outputId, width):\n\nComplete HTML structure with placeholder elements for title and value\nCSS class stat-card for JavaScript binding to find\n\nR function renderStatCard(expr):\n\nUses exprToFunction() pattern (fully written)\nReturns a list with title, value, and status fields\n\nCSS file statcard.css:\n\nCard styling (shadow, padding, typography)\nThree color classes: .status-good, .status-warning, .status-bad\n\nJS file statcard.js:\n\nBinding skeleton with comments\nPlaceholder markers for participant code\n\n\n\n\n\nfind(scope) ‚Äî Locate stat card elements\nfind: function(scope) {\n  return $(scope).find('.stat-card');\n}\nrenderValue(el, data) ‚Äî Update DOM with received data\nrenderValue: function(el, data) {\n  // Set the title and value text\n  $(el).find('.stat-title').text(data.title);\n  $(el).find('.stat-value').text(data.value);\n\n  // Remove any existing status class and add the new one\n  $(el).removeClass('status-good status-warning status-bad');\n  if (data.status) {\n    $(el).addClass('status-' + data.status);\n  }\n}\n\n\n\n\nIn app.R, the server already has:\noutput$kpi_card &lt;- renderStatCard({\n  value &lt;- input$metric_slider\n  status &lt;- case_when(\n    value &gt;= 80 ~ \"good\",\n    value &gt;= 50 ~ \"warning\",\n    TRUE ~ \"bad\"\n  )\n  list(title = \"Performance Score\", value = value, status = status)\n})\nParticipants adjust the slider and watch the card update in real-time with color changes.\nKey references:\n\nPosit. ‚ÄúBuild Custom Output Objects.‚Äù 2024. https://shiny.posit.co/r/articles/build/building-outputs/\nGranjon, David. Outstanding User Interfaces with Shiny. Chapman and Hall/CRC, 2022. Chapter 7.\n\n\n\n\n\n\nContent:\n\nRecap the pattern ‚Äî The binding structure is consistent. Once you‚Äôve built one input binding, you can build any input. Same for outputs.\nShow how these patterns scale ‚Äî Brief mention of:\n\nshinyWidgets ‚Äî Dozens of production-quality inputs built with these exact patterns\nhtmlwidgets ‚Äî Framework for D3.js and other visualization libraries\nshiny.react ‚Äî React components in Shiny using similar binding concepts\n\nResources for going further:\n\n\n\n\n\n\n\nResource\nBest for\n\n\n\n\nOutstanding User Interfaces with Shiny (Granjon)\nDeep dives into binding internals\n\n\nJavaScript for R (Coene)\nJS fundamentals in R context\n\n\nhtmlwidgets documentation\nD3.js and visualization outputs\n\n\nposit-dev/shiny-bindings repo\nEmerging patterns, React integration\n\n\n\nQ&A ‚Äî Open floor for questions\n\nHandouts to share:\n\nOne-page binding method reference card (PDF)\nAnnotated bibliography with URLs (Markdown)\nLink to workshop repository with all solutions\n\nClosing script:\n\n‚ÄúYou‚Äôve now built a custom input and a custom output from scratch. The key insight is that the pattern is always the same: R generates HTML, JavaScript handles behavior, and WebSocket messages connect them. Everything else is just variations on this theme. The resources in the handout will take you deeper when you‚Äôre ready. Thanks for joining‚Äîhappy binding building!‚Äù"
  },
  {
    "objectID": "workshop-outline.html#repository-structure",
    "href": "workshop-outline.html#repository-structure",
    "title": "Workshop Outline: Building Custom Shiny Inputs and Outputs",
    "section": "",
    "text": "shiny-custom-bindings-workshop/\n‚îú‚îÄ‚îÄ README.md                     # Setup instructions, prerequisites\n‚îú‚îÄ‚îÄ 00-demo-finished/\n‚îÇ   ‚îî‚îÄ‚îÄ app.R                     # Finished app showing both components\n‚îú‚îÄ‚îÄ 01-input-starter/\n‚îÇ   ‚îú‚îÄ‚îÄ app.R                     # Starter app with placeholder\n‚îÇ   ‚îú‚îÄ‚îÄ R/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ triStateInput.R       # UI + update functions (complete)\n‚îÇ   ‚îî‚îÄ‚îÄ www/\n‚îÇ       ‚îú‚îÄ‚îÄ css/\n‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ tristate.css      # Styling (complete)\n‚îÇ       ‚îî‚îÄ‚îÄ js/\n‚îÇ           ‚îî‚îÄ‚îÄ tristate.js       # Binding skeleton (to complete)\n‚îú‚îÄ‚îÄ 02-input-solution/\n‚îÇ   ‚îî‚îÄ‚îÄ ...                       # Complete solution for reference\n‚îú‚îÄ‚îÄ 03-output-starter/\n‚îÇ   ‚îú‚îÄ‚îÄ app.R\n‚îÇ   ‚îú‚îÄ‚îÄ R/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ statCard.R            # UI + render functions (complete)\n‚îÇ   ‚îî‚îÄ‚îÄ www/\n‚îÇ       ‚îú‚îÄ‚îÄ css/\n‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ statcard.css      # Styling (complete)\n‚îÇ       ‚îî‚îÄ‚îÄ js/\n‚îÇ           ‚îî‚îÄ‚îÄ statcard.js       # Binding skeleton (to complete)\n‚îú‚îÄ‚îÄ 04-output-solution/\n‚îÇ   ‚îî‚îÄ‚îÄ ...\n‚îî‚îÄ‚îÄ reference/\n    ‚îú‚îÄ‚îÄ binding-cheatsheet.pdf\n    ‚îî‚îÄ‚îÄ resources.md"
  },
  {
    "objectID": "workshop-outline.html#instructor-notes",
    "href": "workshop-outline.html#instructor-notes",
    "title": "Workshop Outline: Building Custom Shiny Inputs and Outputs",
    "section": "",
    "text": "Screen sharing: Use large font size in IDE (14pt minimum). Consider a dark theme for better visibility on varied monitors.\nBreakout rooms: If troubleshooting takes more than 30 seconds for one participant, offer to move them to a breakout room with a TA.\nChat monitoring: Have a co-instructor or TA dedicated to watching chat for questions and flagging urgent issues.\nSolution files: Emphasize that participants who fall behind can copy from the solution folder to catch up. The learning happens from seeing the pattern, not just typing.\n\n\n\n\n\nThe 40-minute input segment has ~5 minutes flexibility\nIf running long: abbreviate receiveMessage() walkthrough (participants can reference solution)\nIf running fast: add the getRatePolicy() extension\nThe output segment is designed to be faster; if the input runs over by 5 minutes, the output can compress to 15 minutes\n\n\n\n\n\n\n\n\n\n\n\nIssue\nSolution\n\n\n\n\n‚ÄúApp won‚Äôt run‚Äù\nCheck working directory is set to project root\n\n\n‚ÄúChanges don‚Äôt appear‚Äù\nHard refresh browser (Ctrl+Shift+R / Cmd+Shift+R)\n\n\n‚ÄúJavaScript error in console‚Äù\nCheck for missing commas, semicolons in binding object\n\n\n‚ÄúInput value is undefined in R‚Äù\nVerify getValue() has explicit return statement\n\n\n\n\n\n\n\nEnsure all code comments are screen-reader friendly (no ASCII art)\nProvide transcript of the finished demo in README\nUse high-contrast colors in diagrams\nShare slides/materials in advance for participants using assistive technology"
  },
  {
    "objectID": "workshop-outline.html#materials-checklist",
    "href": "workshop-outline.html#materials-checklist",
    "title": "Workshop Outline: Building Custom Shiny Inputs and Outputs",
    "section": "",
    "text": "Repository published and tested on clean machine\nREADME with setup verification steps\nDemo GIFs created for finished components\nSlides for conceptual section (10 min)\nBinding cheatsheet PDF\nResources markdown file\nCalendar invite with repo link and setup instructions sent\n\n\n\n\n\nBackup of all materials on local machine\nScreen sharing tested\nBreakout rooms configured\nChat monitoring plan confirmed with TA\nPost-workshop survey link ready"
  },
  {
    "objectID": "workshop-outline.html#references",
    "href": "workshop-outline.html#references",
    "title": "Workshop Outline: Building Custom Shiny Inputs and Outputs",
    "section": "",
    "text": "Posit Software, PBC. ‚ÄúHow to Create Custom Input Bindings.‚Äù 2024. https://shiny.posit.co/r/articles/build/js-custom-input/\nPosit Software, PBC. ‚ÄúBuild Custom Output Objects.‚Äù 2024. https://shiny.posit.co/r/articles/build/building-outputs/\nPosit Software, PBC. ‚ÄúCommunicating with Shiny via JavaScript.‚Äù 2024. https://shiny.posit.co/r/articles/build/communicating-with-js/\nGranjon, David. Outstanding User Interfaces with Shiny. Chapman and Hall/CRC, 2022. https://unleash-shiny.rinterface.com/\nCoene, John. JavaScript for R. Chapman and Hall/CRC, 2021. https://javascript-for-r.com/\n\n\n\nWickham, Hadley. Mastering Shiny: Build Interactive Apps, Reports, and Dashboards Powered by R. O‚ÄôReilly Media, 2021. https://mastering-shiny.org/\nFay, Colin, S√©bastien Rochette, Vincent Guyader, and Cervan Girard. Engineering Production-Grade Shiny Apps. Chapman and Hall/CRC, 2021. https://engineering-shiny.org/\nhtmlwidgets documentation. ‚ÄúCreating a Widget.‚Äù 2024. https://www.htmlwidgets.org/develop_intro.html\nPosit Software, PBC. ‚ÄúShiny Bindings: JavaScript Packages for Custom Bindings.‚Äù GitHub, 2024. https://github.com/posit-dev/shiny-bindings\n\n\n\nshinyWidgets: Custom Inputs Widgets for Shiny. Perrier, Victor, Fanny Meyer, and David Granjon. https://CRAN.R-project.org/package=shinyWidgets\nshinyjs: Easily Improve the User Experience of Your Shiny Apps in Seconds. Attali, Dean. https://CRAN.R-project.org/package=shinyjs\nhtmlwidgets: HTML Widgets for R. Vaidyanathan, Ramnath, et al.¬†https://CRAN.R-project.org/package=htmlwidgets"
  },
  {
    "objectID": "workshop-outline.html#bibtex-citations",
    "href": "workshop-outline.html#bibtex-citations",
    "title": "Workshop Outline: Building Custom Shiny Inputs and Outputs",
    "section": "",
    "text": "For use with pandoc or quarto when producing formal documentation:\n@online{posit2024custominput,\n  author = {{Posit Software, PBC}},\n  title = {How to Create Custom Input Bindings},\n  year = {2024},\n  url = {https://shiny.posit.co/r/articles/build/js-custom-input/},\n  note = {Accessed: 2025-11-26}\n}\n\n@online{posit2024buildingoutputs,\n  author = {{Posit Software, PBC}},\n  title = {Build Custom Output Objects},\n  year = {2024},\n  url = {https://shiny.posit.co/r/articles/build/building-outputs/},\n  note = {Accessed: 2025-11-26}\n}\n\n@online{posit2024communicatingjs,\n  author = {{Posit Software, PBC}},\n  title = {Communicating with Shiny via JavaScript},\n  year = {2024},\n  url = {https://shiny.posit.co/r/articles/build/communicating-with-js/},\n  note = {Accessed: 2025-11-26}\n}\n\n@book{granjon2022outstanding,\n  author = {Granjon, David},\n  title = {Outstanding User Interfaces with Shiny},\n  year = {2022},\n  publisher = {Chapman and Hall/CRC},\n  series = {The R Series},\n  isbn = {978-0-367-64365-2},\n  doi = {10.1201/9781003124924},\n  url = {https://unleash-shiny.rinterface.com/},\n  note = {Accessed: 2025-11-26}\n}\n\n@book{coene2021javascript,\n  author = {Coene, John},\n  title = {JavaScript for R},\n  year = {2021},\n  publisher = {Chapman and Hall/CRC},\n  series = {The R Series},\n  isbn = {978-0-367-68063-3},\n  url = {https://javascript-for-r.com/},\n  note = {Accessed: 2025-11-26}\n}\n\n@book{wickham2021mastering,\n  author = {Wickham, Hadley},\n  title = {Mastering Shiny: Build Interactive Apps, Reports, and Dashboards Powered by R},\n  year = {2021},\n  publisher = {O'Reilly Media},\n  isbn = {978-1-492-04738-4},\n  url = {https://mastering-shiny.org/},\n  note = {Accessed: 2025-11-26}\n}\n\n@book{fay2021engineering,\n  author = {Fay, Colin and Rochette, S√©bastien and Guyader, Vincent and Girard, Cervan},\n  title = {Engineering Production-Grade Shiny Apps},\n  year = {2021},\n  publisher = {Chapman and Hall/CRC},\n  series = {The R Series},\n  isbn = {978-0-367-46602-2},\n  doi = {10.1201/9781003029878},\n  url = {https://engineering-shiny.org/},\n  note = {Accessed: 2025-11-26}\n}\n\n@manual{htmlwidgets2024,\n  title = {htmlwidgets: HTML Widgets for R},\n  author = {Vaidyanathan, Ramnath and Xie, Yihui and Allaire, JJ and Cheng, Joe and Sievert, Carson and Russell, Kenton},\n  year = {2024},\n  note = {R package version 1.6.4},\n  url = {https://CRAN.R-project.org/package=htmlwidgets}\n}\n\n@online{htmlwidgets_develop,\n  author = {Vaidyanathan, Ramnath and Xie, Yihui and Allaire, JJ and Cheng, Joe and Sievert, Carson},\n  title = {Creating a Widget},\n  year = {2024},\n  url = {https://www.htmlwidgets.org/develop_intro.html},\n  note = {Accessed: 2025-11-26}\n}\n\n@manual{shinyWidgets2024,\n  title = {shinyWidgets: Custom Inputs Widgets for Shiny},\n  author = {Perrier, Victor and Meyer, Fanny and Granjon, David},\n  year = {2024},\n  note = {R package version 0.8.7},\n  url = {https://CRAN.R-project.org/package=shinyWidgets}\n}\n\n@manual{shinyjs2024,\n  title = {shinyjs: Easily Improve the User Experience of Your Shiny Apps in Seconds},\n  author = {Attali, Dean},\n  year = {2024},\n  url = {https://CRAN.R-project.org/package=shinyjs}\n}\n\n@misc{shinybindings_github,\n  author = {{Posit Software, PBC}},\n  title = {Shiny Bindings: JavaScript Packages for Custom Bindings},\n  year = {2024},\n  publisher = {GitHub},\n  url = {https://github.com/posit-dev/shiny-bindings},\n  note = {Accessed: 2025-11-26}\n}"
  },
  {
    "objectID": "research.html",
    "href": "research.html",
    "title": "Creating custom R Shiny inputs and outputs: A comprehensive guide",
    "section": "",
    "text": "R Shiny‚Äôs binding system enables developers to create fully custom interactive components by bridging JavaScript and R through a WebSocket-based communication protocol. Custom input bindings allow form widgets to send user data to R, while output bindings render server-side computations in the browser. This bidirectional architecture‚Äîpowered by the Shiny.InputBinding and Shiny.OutputBinding classes‚Äîprovides complete control over component behavior, from simple toggles to complex D3.js visualizations. The framework has matured significantly, with authoritative documentation from Posit and several expert-authored books providing detailed implementation guidance.\n\n\n\nShiny uses WebSockets for real-time, bidirectional communication between the R server and the JavaScript client, powered by the httpuv package. When a Shiny app loads, an HTTP request initiates a WebSocket handshake (HTTP status code 101 switches the protocol from HTTP to WS/WSS), establishing a persistent connection for continuous two-way messaging.\nThe communication flow follows a consistent pattern: input changes travel from browser to R server, while output updates flow from R server to browser. Key functions driving this system include session$sendCustomMessage() for R-to-JavaScript messaging, session$sendInputMessage() for updating input values, and Shiny.setInputValue() on the JavaScript side to set input values programmatically.\nAll input and output components are managed through two central registries: Shiny.inputBindings and Shiny.outputBindings. These registries use a priority system where higher numbers indicate higher priority (default is 0), allowing developers to override built-in bindings when necessary. When Shiny initializes a page, it calls Shiny.bindAll() to scan the DOM and associate each matching element with its appropriate binding.\n\n\n\n\n\n\nThe www/ directory at your Shiny app‚Äôs root serves as the standard location for static files. Files placed here are automatically accessible at URL paths without the www/ prefix‚Äîfor example, www/js/myBinding.js becomes available at /js/myBinding.js. In R packages, use inst/www/ and access files via system.file('www', package='pkg').\nui &lt;- fluidPage(\n  tags$head(\n    tags$script(src = \"js/myBinding.js\"),\n    tags$link(rel = \"stylesheet\", href = \"css/myStyles.css\")\n  )\n)\n\n\n\nFor packages and reusable components, htmltools::htmlDependency() provides the recommended approach. This function automatically handles dependency deduplication‚Äîif the same dependency appears multiple times on a page, Shiny includes it only once, selecting the highest version when conflicts arise.\nmyDependency &lt;- function() {\n  htmltools::htmlDependency(\n    name = \"myComponent\",\n    version = \"1.0.0\",\n    src = c(file = system.file(\"www\", package = \"myPackage\")),\n    script = \"js/myBinding.js\",\n    stylesheet = \"css/myStyles.css\"\n  )\n}\n\nmyInput &lt;- function(inputId, label, value = \"\") {\n  tagList(\n    myDependency(),\n    tags$div(\n      id = inputId, \n      class = \"my-input-class\",\n      tags$label(label),\n      tags$input(type = \"text\", value = value)\n    )\n  )\n}\nThe singleton() wrapper offers an alternative for simpler cases, ensuring that wrapped content appears only once regardless of how many times the function is called. For package development, addResourcePath() creates named URL prefixes mapping to local directories.\n\n\n\n\n\nCustom input bindings extend Shiny.InputBinding using jQuery‚Äôs $.extend() pattern. All instances of the same input type share a single binding object, with individual elements passed as parameters to each method.\n\n\nThe find(scope) method locates all instances of your input component within a given scope (usually the document). It must return an array-like object of matching elements, typically using jQuery‚Äôs class-based selectors to support multiple instances:\nfind: function(scope) {\n  return $(scope).find('.my-input-class');\n}\nThe getValue(el) method extracts and returns the current value to send to R. This function must include an explicit return statement‚Äîomitting it causes the binding to fail silently. Values can be primitives or objects (which become lists in R):\ngetValue: function(el) {\n  return {\n    value: $(el).val(),\n    collapsed: $(el).hasClass('collapsed-box')\n  };\n}\nThe subscribe(el, callback) method sets up event listeners to detect value changes. Use jQuery event namespacing (e.g., change.myBinding) for clean unsubscription. The callback function accepts an optional boolean parameter‚Äîpassing true applies the rate policy defined in getRatePolicy():\nsubscribe: function(el, callback) {\n  $(el).on(\"change.myBinding\", function(e) {\n    callback();  // Immediate send\n  });\n  $(el).on(\"keyup.myBinding\", function(e) {\n    callback(true);  // Apply rate policy\n  });\n}\n\n\n\nThe setValue(el, value) method programmatically sets the input‚Äôs value, essential for updateInput functions. The receiveMessage(el, data) method handles messages sent from R via session$sendInputMessage(), typically calling setValue() and triggering a change event:\nreceiveMessage: function(el, data) {\n  if (data.hasOwnProperty('value')) {\n    this.setValue(el, data.value);\n    $(el).trigger('change');\n  }\n}\nThe getRatePolicy() method controls update frequency with three policies: \"direct\" sends immediately, \"debounce\" waits until no new values arrive for the specified delay (ideal for text inputs), and \"throttle\" limits updates to at most one per delay period (ideal for sliders):\ngetRatePolicy: function() {\n  return { policy: 'debounce', delay: 250 };\n}\nThe getType() method returns a string identifying a custom input handler for R-side data deserialization, connecting to handlers registered via shiny::registerInputHandler(). The initialize(el) method runs once per element before other methods, essential for initializing third-party JavaScript libraries.\n\n\n\nvar myBinding = new Shiny.InputBinding();\n$.extend(myBinding, {\n  find: function(scope) { return $(scope).find('.my-input'); },\n  getValue: function(el) { return $(el).val(); },\n  setValue: function(el, value) { $(el).val(value); },\n  subscribe: function(el, callback) {\n    $(el).on('change.myBinding keyup.myBinding', function() { callback(true); });\n  },\n  unsubscribe: function(el) { $(el).off('.myBinding'); },\n  receiveMessage: function(el, data) {\n    if (data.value !== undefined) {\n      this.setValue(el, data.value);\n      $(el).trigger('change');\n    }\n  },\n  getRatePolicy: function() { return { policy: 'debounce', delay: 250 }; }\n});\n\nShiny.inputBindings.register(myBinding, 'mypackage.myInput');\n\n\n\n\n\n\n\nThe shinyWidgets package demonstrates effective patterns for multi-select inputs. The key is returning an array of selected values (or null for empty selections) and handling the DOM events from the underlying library:\nvar multiInputBinding = new Shiny.InputBinding();\n$.extend(multiInputBinding, {\n  find: function(scope) { return $(scope).find(\".multi-input\"); },\n  getValue: function(el) {\n    var selected = [];\n    $(el).find(\"option:selected\").each(function() {\n      selected.push($(this).val());\n    });\n    return selected.length === 0 ? null : selected;\n  },\n  subscribe: function(el, callback) {\n    $(el).on(\"change.multiInput\", function() { callback(); });\n  }\n});\n\n\n\nFor complex widgets like collapsible boxes that need to track multiple state properties, embed configuration in a &lt;script type=\"application/json\"&gt; tag and return an object from getValue():\ngetValue: function(el) {\n  var config = JSON.parse($(el).find('script[data-for=\"' + el.id + '\"]').html());\n  return {\n    collapsed: $(el).hasClass('collapsed-box'),\n    width: config.width,\n    title: config.title\n  };\n}\n\n\n\nCustom bindings can implement two methods for validation display. The setInvalid(el, data) method displays validation errors, receiving an object with type and message properties. The clearInvalid(el) method removes error displays:\nsetInvalid: function(el, data) {\n  $(el).addClass('is-invalid');\n  $(el).after('&lt;span class=\"validation-message text-danger\"&gt;' + data.message + '&lt;/span&gt;');\n},\nclearInvalid: function(el) {\n  $(el).removeClass('is-invalid');\n  $(el).parent().find('.validation-message').remove();\n}\n\n\n\n\n\nOutput bindings follow a simpler pattern than inputs, primarily requiring find() and renderValue() methods.\n\n\nThe find(scope) method works identically to input bindings, locating output elements by class. The renderValue(el, data) method receives data from R (converted to JSON via shiny:::toJSON()) and renders it to the element:\nvar myOutputBinding = new Shiny.OutputBinding();\n$.extend(myOutputBinding, {\n  find: function(scope) { return $(scope).find('.my-output'); },\n  renderValue: function(el, data) {\n    el.style.backgroundColor = data.color;\n    document.getElementById(el.id + '-title').innerText = data.title;\n  },\n  renderError: function(el, error) {\n    el.innerHTML = '&lt;span class=\"error\"&gt;' + error.message + '&lt;/span&gt;';\n  },\n  clearError: function(el) {\n    $(el).find('.error').remove();\n  }\n});\nShiny.outputBindings.register(myOutputBinding, 'mypackage.myOutput');\n\n\n\nCreating a custom output requires three R functions: a UI generator, a render function using exprToFunction(), and optionally an HTML dependency function:\nmyOutput &lt;- function(outputId, width = '100%', height = '400px') {\n  tagList(\n    myOutputDependency(),\n    tags$div(id = outputId, class = 'my-output', \n             style = sprintf('width: %s; height: %s;', width, height))\n  )\n}\n\nrenderMyOutput &lt;- function(expr, env = parent.frame(), quoted = FALSE) {\n  func &lt;- exprToFunction(expr, env, quoted)\n  function() {\n    val &lt;- func()\n    list(title = val$title, color = val$color)\n  }\n}\n\n\n\n\n\n\n\nThe r2d3 package provides the most streamlined approach to D3.js integration, handling the binding infrastructure automatically:\nlibrary(r2d3)\noutput$d3 &lt;- renderD3({\n  r2d3(runif(5, 0, input$max_value), script = \"barchart.js\")\n})\nWithin D3 scripts, communicate back to Shiny using Shiny.setInputValue():\nsvg.selectAll(\"rect\").data(data)\n  .enter().append(\"rect\")\n  .on(\"click\", function(d) {\n    Shiny.setInputValue(\"bar_clicked\", d, {priority: \"event\"});\n  });\n\n\n\nThe htmlwidgets package provides a comprehensive framework for creating R bindings to JavaScript libraries that work seamlessly across R console, R Markdown, Shiny, and standalone HTML. Widgets use a factory function pattern returning renderValue() and resize() methods:\nHTMLWidgets.widget({\n  name: 'mywidget',\n  type: 'output',\n  factory: function(el, width, height) {\n    var instance = new MyLibrary(el.id);\n    return {\n      renderValue: function(x) {\n        instance.setData(x.data);\n        instance.render();\n      },\n      resize: function(width, height) {\n        instance.resize(width, height);\n      }\n    };\n  }\n});\nMajor packages built on htmlwidgets include plotly for interactive charts, leaflet for maps, DT for tables, dygraphs for time series, and networkD3 for network visualizations.\n\n\n\nThe sizing policy in htmlwidgets controls how widgets respond to container changes across different contexts. For custom output bindings, listen for window resize events and update visualizations accordingly:\nresize: function(width, height) {\n  d3.select(el).select(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height);\n  force.size([width, height]).resume();\n}\n\n\n\n\n\n\n\nBy default, Shiny optimizes by ignoring duplicate values. To treat every call as an event regardless of value:\nShiny.setInputValue(\"myevent\", value, {priority: \"event\"});\nCustom input handlers enable type-specific deserialization. Register handlers in your package‚Äôs .onLoad() function and reference them with a colon suffix in JavaScript:\nregisterInputHandler(\"mypackage.dateTime\", function(x, session, inputname) {\n  as.POSIXct(x, origin = \"1970-01-01\")\n})\nShiny.setInputValue(\"timestamp:mypackage.dateTime\", Date.now());\n\n\n\nThe session$sendCustomMessage() function sends arbitrary data from R to JavaScript, paired with handlers registered via Shiny.addCustomMessageHandler():\n# R server\nobserve({\n  session$sendCustomMessage(\"update-chart\", list(data = processed_data))\n})\n// JavaScript\nShiny.addCustomMessageHandler(\"update-chart\", function(message) {\n  updateVisualization(message.data);\n});\nImportant for modules: sendCustomMessage() does not automatically namespace message types. When using modules, manually include namespaced IDs in the message payload:\n# In module server\nsession$sendCustomMessage(\"handler\", list(id = ns(\"target_input\"), value = data))\n\n\n\nWhen dynamically modifying the DOM, ensure proper binding lifecycle management:\nShiny.unbindAll(scope);\n// ... modify DOM ...\nShiny.initializeInputs();\nShiny.bindAll(scope);\nFor content insertion, use Shiny.renderContent() which handles this automatically.\n\n\n\n\n\n\n\nThe shinytest2 package supports testing custom bindings. For inputs without standard bindings, use the allow_no_input_binding_ parameter:\ntest_that(\"Custom input works\", {\n  app &lt;- AppDriver$new()\n  app$set_inputs(table_rows_selected = 1, allow_no_input_binding_ = TRUE)\n  app$expect_values()\n})\nFor robust tests, add data-testid attributes to components and locate elements by this stable identifier rather than potentially changing IDs.\n\n\n\nEnable comprehensive R-side debugging with options(shiny.trace = TRUE) to view WebSocket traffic, showing all messages between browser and server. The reactive log (reactlog::reactlog_enable()) visualizes dependency relationships.\nFor JavaScript debugging, use browser developer tools with the debugger; statement to pause execution. In RStudio Desktop on macOS, enable WebKit Developer Tools with:\ndefaults write org.rstudio.RStudio WebKitDeveloperExtras -bool true\n\n\n\nImplement getRatePolicy() to prevent flooding the server with rapid updates. For bindings wrapping third-party libraries that trigger many events, use manual debouncing:\nsubscribe: function(el, callback) {\n  var timeout = null;\n  $(el).on('slide', function() {\n    if (timeout) clearTimeout(timeout);\n    timeout = setTimeout(function() { callback(); }, 100);\n  });\n}\nClean up properly in unsubscribe() to prevent memory leaks:\nunsubscribe: function(el) {\n  $(el).off('.myBinding');\n  $(el).removeData('myPlugin');\n}\n\n\n\n\n\nThe shinyWidgets package by Victor Perrier and Fanny Meyer provides dozens of production-quality input bindings including multi-selects, sliders, and switches. Its source code demonstrates comprehensive implementation patterns for complex widgets. The shinyjs package by Dean Attali shows how to execute arbitrary JavaScript from R without complex binding infrastructure.\nThe htmlwidgets package, maintained by Carson Sievert at Posit, provides the foundational framework that powers plotly, leaflet, and DT. For React integration, reactR by Kent Russell creates htmlwidgets using React components, while Appsilon‚Äôs shiny.react offers an alternative approach for building React-based Shiny components.\n\n\n\n\nCreating custom Shiny bindings requires understanding three interconnected systems: the R-side functions generating HTML and handling messages, the JavaScript binding classes managing DOM interaction, and the WebSocket protocol connecting them. The Shiny.InputBinding class with its find(), getValue(), subscribe(), and receiveMessage() methods forms the foundation for all custom inputs, while Shiny.OutputBinding with renderValue() handles custom outputs.\nFor production applications, prioritize using htmltools::htmlDependency() for asset management, implement proper rate limiting, handle validation states, and ensure cleanup in unsubscribe(). The htmlwidgets framework significantly reduces boilerplate for visualization outputs. Testing with shinytest2 and debugging with options(shiny.trace = TRUE) catch issues before deployment. As the ecosystem matures, the posit-dev/shiny-bindings repository provides emerging patterns for React component integration, pointing toward increasingly sophisticated component architectures.\n\n\n\n\n@online{posit2024shiny,\n  author = {{Posit Software, PBC}},\n  title = {Shiny for R: Articles and Documentation},\n  year = {2024},\n  url = {https://shiny.posit.co/r/articles/},\n  note = {Accessed: 2025-11-26}\n}\n\n@online{posit2024custominput,\n  author = {{Posit Software, PBC}},\n  title = {How to Create Custom Input Bindings},\n  year = {2024},\n  url = {https://shiny.posit.co/r/articles/build/js-custom-input/},\n  note = {Accessed: 2025-11-26}\n}\n\n@online{posit2024buildinginputs,\n  author = {{Posit Software, PBC}},\n  title = {Build Custom Input Objects},\n  year = {2024},\n  url = {https://shiny.posit.co/r/articles/build/building-inputs/},\n  note = {Accessed: 2025-11-26}\n}\n\n@online{posit2024communicatingjs,\n  author = {{Posit Software, PBC}},\n  title = {Communicating with Shiny via JavaScript},\n  year = {2024},\n  url = {https://shiny.posit.co/r/articles/build/communicating-with-js/},\n  note = {Accessed: 2025-11-26}\n}\n\n@online{posit2024packagingjs,\n  author = {{Posit Software, PBC}},\n  title = {Packaging JavaScript Code for Shiny},\n  year = {2024},\n  url = {https://shiny.posit.co/r/articles/build/packaging-javascript/},\n  note = {Accessed: 2025-11-26}\n}\n\n@online{posit2024buildingoutputs,\n  author = {{Posit Software, PBC}},\n  title = {Build Custom Output Objects},\n  year = {2024},\n  url = {https://shiny.posit.co/r/articles/build/building-outputs/},\n  note = {Accessed: 2025-11-26}\n}\n\n@book{wickham2021mastering,\n  author = {Wickham, Hadley},\n  title = {Mastering Shiny: Build Interactive Apps, Reports, and Dashboards Powered by R},\n  year = {2021},\n  publisher = {O'Reilly Media},\n  isbn = {978-1-492-04738-4},\n  url = {https://mastering-shiny.org/},\n  note = {Accessed: 2025-11-26}\n}\n\n@book{coene2021javascript,\n  author = {Coene, John},\n  title = {JavaScript for R},\n  year = {2021},\n  publisher = {Chapman and Hall/CRC},\n  series = {The R Series},\n  isbn = {978-0-367-68063-3},\n  url = {https://javascript-for-r.com/},\n  note = {Accessed: 2025-11-26}\n}\n\n@book{granjon2022outstanding,\n  author = {Granjon, David},\n  title = {Outstanding User Interfaces with Shiny},\n  year = {2022},\n  publisher = {Chapman and Hall/CRC},\n  series = {The R Series},\n  isbn = {978-0-367-64365-2},\n  doi = {10.1201/9781003124924},\n  url = {https://unleash-shiny.rinterface.com/},\n  note = {Accessed: 2025-11-26}\n}\n\n@book{fay2021engineering,\n  author = {Fay, Colin and Rochette, S√©bastien and Guyader, Vincent and Girard, Cervan},\n  title = {Engineering Production-Grade Shiny Apps},\n  year = {2021},\n  publisher = {Chapman and Hall/CRC},\n  series = {The R Series},\n  isbn = {978-0-367-46602-2},\n  doi = {10.1201/9781003029878},\n  url = {https://engineering-shiny.org/},\n  note = {Accessed: 2025-11-26}\n}\n\n@manual{htmlwidgets2024,\n  title = {htmlwidgets: HTML Widgets for R},\n  author = {Vaidyanathan, Ramnath and Xie, Yihui and Allaire, JJ and Cheng, Joe and Sievert, Carson and Russell, Kenton},\n  year = {2024},\n  note = {R package version 1.6.4},\n  url = {https://CRAN.R-project.org/package=htmlwidgets}\n}\n\n@online{htmlwidgets_develop,\n  author = {Vaidyanathan, Ramnath and Xie, Yihui and Allaire, JJ and Cheng, Joe and Sievert, Carson},\n  title = {Creating a Widget},\n  year = {2024},\n  url = {https://www.htmlwidgets.org/develop_intro.html},\n  note = {Accessed: 2025-11-26}\n}\n\n@online{htmlwidgets_sizing,\n  author = {Vaidyanathan, Ramnath and Xie, Yihui and Allaire, JJ and Cheng, Joe and Sievert, Carson},\n  title = {Widget Sizing},\n  year = {2024},\n  url = {https://www.htmlwidgets.org/develop_sizing.html},\n  note = {Accessed: 2025-11-26}\n}\n\n@manual{shinyWidgets2024,\n  title = {shinyWidgets: Custom Inputs Widgets for Shiny},\n  author = {Perrier, Victor and Meyer, Fanny and Granjon, David},\n  year = {2024},\n  note = {R package version 0.8.7},\n  url = {https://CRAN.R-project.org/package=shinyWidgets}\n}\n\n@manual{shinyjs2024,\n  title = {shinyjs: Easily Improve the User Experience of Your Shiny Apps in Seconds},\n  author = {Attali, Dean},\n  year = {2024},\n  url = {https://CRAN.R-project.org/package=shinyjs}\n}\n\n@manual{reactR2024,\n  title = {reactR: React Helpers},\n  author = {Russell, Kent and Dipert, Alan},\n  year = {2024},\n  url = {https://CRAN.R-project.org/package=reactR}\n}\n\n@manual{shinyreact2024,\n  title = {shiny.react: Tools for Using React in Shiny},\n  author = {Sobolewski, Jakub and ≈ªy≈Ça, Kamil and Rogala, Marek and {Appsilon Sp. z o.o.}},\n  year = {2024},\n  url = {https://CRAN.R-project.org/package=shiny.react}\n}\n\n@manual{golem2024,\n  title = {golem: A Framework for Robust Shiny Applications},\n  author = {Fay, Colin and Guyader, Vincent and Rochette, S√©bastien and Girard, Cervan},\n  year = {2024},\n  url = {https://CRAN.R-project.org/package=golem}\n}\n\n@online{r2d3_shiny,\n  author = {{RStudio}},\n  title = {Using r2d3 with Shiny},\n  year = {2024},\n  url = {https://rstudio.github.io/r2d3/articles/shiny.html},\n  note = {Accessed: 2025-11-26}\n}\n\n@online{shinytest2_docs,\n  author = {{Posit Software, PBC}},\n  title = {shinytest2: Testing Shiny Applications},\n  year = {2024},\n  url = {https://rstudio.github.io/shinytest2/},\n  note = {Accessed: 2025-11-26}\n}\n\n@online{shinyvalidate_displaying,\n  author = {Cheng, Joe and {Posit Software, PBC}},\n  title = {Displaying Validation Feedback},\n  year = {2024},\n  url = {https://rstudio.github.io/shinyvalidate/articles/displaying.html},\n  note = {Accessed: 2025-11-26}\n}\n\n@online{posit2024debugging,\n  author = {{Posit Software, PBC}},\n  title = {Debugging Shiny Applications},\n  year = {2024},\n  url = {https://shiny.posit.co/r/articles/improve/debugging/},\n  note = {Accessed: 2025-11-26}\n}\n\n@misc{shiny_github,\n  author = {{Posit Software, PBC}},\n  title = {Shiny: Web Application Framework for R},\n  year = {2024},\n  publisher = {GitHub},\n  url = {https://github.com/rstudio/shiny},\n  note = {Accessed: 2025-11-26}\n}\n\n@misc{shinybindings_github,\n  author = {{Posit Software, PBC}},\n  title = {Shiny Bindings: JavaScript Packages for Custom Bindings},\n  year = {2024},\n  publisher = {GitHub},\n  url = {https://github.com/posit-dev/shiny-bindings},\n  note = {Accessed: 2025-11-26}\n}"
  },
  {
    "objectID": "research.html#how-shinys-inputoutput-system-works-under-the-hood",
    "href": "research.html#how-shinys-inputoutput-system-works-under-the-hood",
    "title": "Creating custom R Shiny inputs and outputs: A comprehensive guide",
    "section": "",
    "text": "Shiny uses WebSockets for real-time, bidirectional communication between the R server and the JavaScript client, powered by the httpuv package. When a Shiny app loads, an HTTP request initiates a WebSocket handshake (HTTP status code 101 switches the protocol from HTTP to WS/WSS), establishing a persistent connection for continuous two-way messaging.\nThe communication flow follows a consistent pattern: input changes travel from browser to R server, while output updates flow from R server to browser. Key functions driving this system include session$sendCustomMessage() for R-to-JavaScript messaging, session$sendInputMessage() for updating input values, and Shiny.setInputValue() on the JavaScript side to set input values programmatically.\nAll input and output components are managed through two central registries: Shiny.inputBindings and Shiny.outputBindings. These registries use a priority system where higher numbers indicate higher priority (default is 0), allowing developers to override built-in bindings when necessary. When Shiny initializes a page, it calls Shiny.bindAll() to scan the DOM and associate each matching element with its appropriate binding."
  },
  {
    "objectID": "research.html#integrating-javascript-css-and-shiny-applications",
    "href": "research.html#integrating-javascript-css-and-shiny-applications",
    "title": "Creating custom R Shiny inputs and outputs: A comprehensive guide",
    "section": "",
    "text": "The www/ directory at your Shiny app‚Äôs root serves as the standard location for static files. Files placed here are automatically accessible at URL paths without the www/ prefix‚Äîfor example, www/js/myBinding.js becomes available at /js/myBinding.js. In R packages, use inst/www/ and access files via system.file('www', package='pkg').\nui &lt;- fluidPage(\n  tags$head(\n    tags$script(src = \"js/myBinding.js\"),\n    tags$link(rel = \"stylesheet\", href = \"css/myStyles.css\")\n  )\n)\n\n\n\nFor packages and reusable components, htmltools::htmlDependency() provides the recommended approach. This function automatically handles dependency deduplication‚Äîif the same dependency appears multiple times on a page, Shiny includes it only once, selecting the highest version when conflicts arise.\nmyDependency &lt;- function() {\n  htmltools::htmlDependency(\n    name = \"myComponent\",\n    version = \"1.0.0\",\n    src = c(file = system.file(\"www\", package = \"myPackage\")),\n    script = \"js/myBinding.js\",\n    stylesheet = \"css/myStyles.css\"\n  )\n}\n\nmyInput &lt;- function(inputId, label, value = \"\") {\n  tagList(\n    myDependency(),\n    tags$div(\n      id = inputId, \n      class = \"my-input-class\",\n      tags$label(label),\n      tags$input(type = \"text\", value = value)\n    )\n  )\n}\nThe singleton() wrapper offers an alternative for simpler cases, ensuring that wrapped content appears only once regardless of how many times the function is called. For package development, addResourcePath() creates named URL prefixes mapping to local directories."
  },
  {
    "objectID": "research.html#the-shiny.inputbinding-class-and-its-methods",
    "href": "research.html#the-shiny.inputbinding-class-and-its-methods",
    "title": "Creating custom R Shiny inputs and outputs: A comprehensive guide",
    "section": "",
    "text": "Custom input bindings extend Shiny.InputBinding using jQuery‚Äôs $.extend() pattern. All instances of the same input type share a single binding object, with individual elements passed as parameters to each method.\n\n\nThe find(scope) method locates all instances of your input component within a given scope (usually the document). It must return an array-like object of matching elements, typically using jQuery‚Äôs class-based selectors to support multiple instances:\nfind: function(scope) {\n  return $(scope).find('.my-input-class');\n}\nThe getValue(el) method extracts and returns the current value to send to R. This function must include an explicit return statement‚Äîomitting it causes the binding to fail silently. Values can be primitives or objects (which become lists in R):\ngetValue: function(el) {\n  return {\n    value: $(el).val(),\n    collapsed: $(el).hasClass('collapsed-box')\n  };\n}\nThe subscribe(el, callback) method sets up event listeners to detect value changes. Use jQuery event namespacing (e.g., change.myBinding) for clean unsubscription. The callback function accepts an optional boolean parameter‚Äîpassing true applies the rate policy defined in getRatePolicy():\nsubscribe: function(el, callback) {\n  $(el).on(\"change.myBinding\", function(e) {\n    callback();  // Immediate send\n  });\n  $(el).on(\"keyup.myBinding\", function(e) {\n    callback(true);  // Apply rate policy\n  });\n}\n\n\n\nThe setValue(el, value) method programmatically sets the input‚Äôs value, essential for updateInput functions. The receiveMessage(el, data) method handles messages sent from R via session$sendInputMessage(), typically calling setValue() and triggering a change event:\nreceiveMessage: function(el, data) {\n  if (data.hasOwnProperty('value')) {\n    this.setValue(el, data.value);\n    $(el).trigger('change');\n  }\n}\nThe getRatePolicy() method controls update frequency with three policies: \"direct\" sends immediately, \"debounce\" waits until no new values arrive for the specified delay (ideal for text inputs), and \"throttle\" limits updates to at most one per delay period (ideal for sliders):\ngetRatePolicy: function() {\n  return { policy: 'debounce', delay: 250 };\n}\nThe getType() method returns a string identifying a custom input handler for R-side data deserialization, connecting to handlers registered via shiny::registerInputHandler(). The initialize(el) method runs once per element before other methods, essential for initializing third-party JavaScript libraries.\n\n\n\nvar myBinding = new Shiny.InputBinding();\n$.extend(myBinding, {\n  find: function(scope) { return $(scope).find('.my-input'); },\n  getValue: function(el) { return $(el).val(); },\n  setValue: function(el, value) { $(el).val(value); },\n  subscribe: function(el, callback) {\n    $(el).on('change.myBinding keyup.myBinding', function() { callback(true); });\n  },\n  unsubscribe: function(el) { $(el).off('.myBinding'); },\n  receiveMessage: function(el, data) {\n    if (data.value !== undefined) {\n      this.setValue(el, data.value);\n      $(el).trigger('change');\n    }\n  },\n  getRatePolicy: function() { return { policy: 'debounce', delay: 250 }; }\n});\n\nShiny.inputBindings.register(myBinding, 'mypackage.myInput');"
  },
  {
    "objectID": "research.html#building-complex-form-widgets-with-custom-bindings",
    "href": "research.html#building-complex-form-widgets-with-custom-bindings",
    "title": "Creating custom R Shiny inputs and outputs: A comprehensive guide",
    "section": "",
    "text": "The shinyWidgets package demonstrates effective patterns for multi-select inputs. The key is returning an array of selected values (or null for empty selections) and handling the DOM events from the underlying library:\nvar multiInputBinding = new Shiny.InputBinding();\n$.extend(multiInputBinding, {\n  find: function(scope) { return $(scope).find(\".multi-input\"); },\n  getValue: function(el) {\n    var selected = [];\n    $(el).find(\"option:selected\").each(function() {\n      selected.push($(this).val());\n    });\n    return selected.length === 0 ? null : selected;\n  },\n  subscribe: function(el, callback) {\n    $(el).on(\"change.multiInput\", function() { callback(); });\n  }\n});\n\n\n\nFor complex widgets like collapsible boxes that need to track multiple state properties, embed configuration in a &lt;script type=\"application/json\"&gt; tag and return an object from getValue():\ngetValue: function(el) {\n  var config = JSON.parse($(el).find('script[data-for=\"' + el.id + '\"]').html());\n  return {\n    collapsed: $(el).hasClass('collapsed-box'),\n    width: config.width,\n    title: config.title\n  };\n}\n\n\n\nCustom bindings can implement two methods for validation display. The setInvalid(el, data) method displays validation errors, receiving an object with type and message properties. The clearInvalid(el) method removes error displays:\nsetInvalid: function(el, data) {\n  $(el).addClass('is-invalid');\n  $(el).after('&lt;span class=\"validation-message text-danger\"&gt;' + data.message + '&lt;/span&gt;');\n},\nclearInvalid: function(el) {\n  $(el).removeClass('is-invalid');\n  $(el).parent().find('.validation-message').remove();\n}"
  },
  {
    "objectID": "research.html#the-shiny.outputbinding-class-for-custom-outputs",
    "href": "research.html#the-shiny.outputbinding-class-for-custom-outputs",
    "title": "Creating custom R Shiny inputs and outputs: A comprehensive guide",
    "section": "",
    "text": "Output bindings follow a simpler pattern than inputs, primarily requiring find() and renderValue() methods.\n\n\nThe find(scope) method works identically to input bindings, locating output elements by class. The renderValue(el, data) method receives data from R (converted to JSON via shiny:::toJSON()) and renders it to the element:\nvar myOutputBinding = new Shiny.OutputBinding();\n$.extend(myOutputBinding, {\n  find: function(scope) { return $(scope).find('.my-output'); },\n  renderValue: function(el, data) {\n    el.style.backgroundColor = data.color;\n    document.getElementById(el.id + '-title').innerText = data.title;\n  },\n  renderError: function(el, error) {\n    el.innerHTML = '&lt;span class=\"error\"&gt;' + error.message + '&lt;/span&gt;';\n  },\n  clearError: function(el) {\n    $(el).find('.error').remove();\n  }\n});\nShiny.outputBindings.register(myOutputBinding, 'mypackage.myOutput');\n\n\n\nCreating a custom output requires three R functions: a UI generator, a render function using exprToFunction(), and optionally an HTML dependency function:\nmyOutput &lt;- function(outputId, width = '100%', height = '400px') {\n  tagList(\n    myOutputDependency(),\n    tags$div(id = outputId, class = 'my-output', \n             style = sprintf('width: %s; height: %s;', width, height))\n  )\n}\n\nrenderMyOutput &lt;- function(expr, env = parent.frame(), quoted = FALSE) {\n  func &lt;- exprToFunction(expr, env, quoted)\n  function() {\n    val &lt;- func()\n    list(title = val$title, color = val$color)\n  }\n}"
  },
  {
    "objectID": "research.html#integrating-d3.js-and-interactive-visualizations",
    "href": "research.html#integrating-d3.js-and-interactive-visualizations",
    "title": "Creating custom R Shiny inputs and outputs: A comprehensive guide",
    "section": "",
    "text": "The r2d3 package provides the most streamlined approach to D3.js integration, handling the binding infrastructure automatically:\nlibrary(r2d3)\noutput$d3 &lt;- renderD3({\n  r2d3(runif(5, 0, input$max_value), script = \"barchart.js\")\n})\nWithin D3 scripts, communicate back to Shiny using Shiny.setInputValue():\nsvg.selectAll(\"rect\").data(data)\n  .enter().append(\"rect\")\n  .on(\"click\", function(d) {\n    Shiny.setInputValue(\"bar_clicked\", d, {priority: \"event\"});\n  });\n\n\n\nThe htmlwidgets package provides a comprehensive framework for creating R bindings to JavaScript libraries that work seamlessly across R console, R Markdown, Shiny, and standalone HTML. Widgets use a factory function pattern returning renderValue() and resize() methods:\nHTMLWidgets.widget({\n  name: 'mywidget',\n  type: 'output',\n  factory: function(el, width, height) {\n    var instance = new MyLibrary(el.id);\n    return {\n      renderValue: function(x) {\n        instance.setData(x.data);\n        instance.render();\n      },\n      resize: function(width, height) {\n        instance.resize(width, height);\n      }\n    };\n  }\n});\nMajor packages built on htmlwidgets include plotly for interactive charts, leaflet for maps, DT for tables, dygraphs for time series, and networkD3 for network visualizations.\n\n\n\nThe sizing policy in htmlwidgets controls how widgets respond to container changes across different contexts. For custom output bindings, listen for window resize events and update visualizations accordingly:\nresize: function(width, height) {\n  d3.select(el).select(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height);\n  force.size([width, height]).resume();\n}"
  },
  {
    "objectID": "research.html#advanced-communication-patterns-between-r-and-javascript",
    "href": "research.html#advanced-communication-patterns-between-r-and-javascript",
    "title": "Creating custom R Shiny inputs and outputs: A comprehensive guide",
    "section": "",
    "text": "By default, Shiny optimizes by ignoring duplicate values. To treat every call as an event regardless of value:\nShiny.setInputValue(\"myevent\", value, {priority: \"event\"});\nCustom input handlers enable type-specific deserialization. Register handlers in your package‚Äôs .onLoad() function and reference them with a colon suffix in JavaScript:\nregisterInputHandler(\"mypackage.dateTime\", function(x, session, inputname) {\n  as.POSIXct(x, origin = \"1970-01-01\")\n})\nShiny.setInputValue(\"timestamp:mypackage.dateTime\", Date.now());\n\n\n\nThe session$sendCustomMessage() function sends arbitrary data from R to JavaScript, paired with handlers registered via Shiny.addCustomMessageHandler():\n# R server\nobserve({\n  session$sendCustomMessage(\"update-chart\", list(data = processed_data))\n})\n// JavaScript\nShiny.addCustomMessageHandler(\"update-chart\", function(message) {\n  updateVisualization(message.data);\n});\nImportant for modules: sendCustomMessage() does not automatically namespace message types. When using modules, manually include namespaced IDs in the message payload:\n# In module server\nsession$sendCustomMessage(\"handler\", list(id = ns(\"target_input\"), value = data))\n\n\n\nWhen dynamically modifying the DOM, ensure proper binding lifecycle management:\nShiny.unbindAll(scope);\n// ... modify DOM ...\nShiny.initializeInputs();\nShiny.bindAll(scope);\nFor content insertion, use Shiny.renderContent() which handles this automatically."
  },
  {
    "objectID": "research.html#testing-and-debugging-custom-bindings",
    "href": "research.html#testing-and-debugging-custom-bindings",
    "title": "Creating custom R Shiny inputs and outputs: A comprehensive guide",
    "section": "",
    "text": "The shinytest2 package supports testing custom bindings. For inputs without standard bindings, use the allow_no_input_binding_ parameter:\ntest_that(\"Custom input works\", {\n  app &lt;- AppDriver$new()\n  app$set_inputs(table_rows_selected = 1, allow_no_input_binding_ = TRUE)\n  app$expect_values()\n})\nFor robust tests, add data-testid attributes to components and locate elements by this stable identifier rather than potentially changing IDs.\n\n\n\nEnable comprehensive R-side debugging with options(shiny.trace = TRUE) to view WebSocket traffic, showing all messages between browser and server. The reactive log (reactlog::reactlog_enable()) visualizes dependency relationships.\nFor JavaScript debugging, use browser developer tools with the debugger; statement to pause execution. In RStudio Desktop on macOS, enable WebKit Developer Tools with:\ndefaults write org.rstudio.RStudio WebKitDeveloperExtras -bool true\n\n\n\nImplement getRatePolicy() to prevent flooding the server with rapid updates. For bindings wrapping third-party libraries that trigger many events, use manual debouncing:\nsubscribe: function(el, callback) {\n  var timeout = null;\n  $(el).on('slide', function() {\n    if (timeout) clearTimeout(timeout);\n    timeout = setTimeout(function() { callback(); }, 100);\n  });\n}\nClean up properly in unsubscribe() to prevent memory leaks:\nunsubscribe: function(el) {\n  $(el).off('.myBinding');\n  $(el).removeData('myPlugin');\n}"
  },
  {
    "objectID": "research.html#key-packages-demonstrating-best-practices",
    "href": "research.html#key-packages-demonstrating-best-practices",
    "title": "Creating custom R Shiny inputs and outputs: A comprehensive guide",
    "section": "",
    "text": "The shinyWidgets package by Victor Perrier and Fanny Meyer provides dozens of production-quality input bindings including multi-selects, sliders, and switches. Its source code demonstrates comprehensive implementation patterns for complex widgets. The shinyjs package by Dean Attali shows how to execute arbitrary JavaScript from R without complex binding infrastructure.\nThe htmlwidgets package, maintained by Carson Sievert at Posit, provides the foundational framework that powers plotly, leaflet, and DT. For React integration, reactR by Kent Russell creates htmlwidgets using React components, while Appsilon‚Äôs shiny.react offers an alternative approach for building React-based Shiny components."
  },
  {
    "objectID": "research.html#conclusion",
    "href": "research.html#conclusion",
    "title": "Creating custom R Shiny inputs and outputs: A comprehensive guide",
    "section": "",
    "text": "Creating custom Shiny bindings requires understanding three interconnected systems: the R-side functions generating HTML and handling messages, the JavaScript binding classes managing DOM interaction, and the WebSocket protocol connecting them. The Shiny.InputBinding class with its find(), getValue(), subscribe(), and receiveMessage() methods forms the foundation for all custom inputs, while Shiny.OutputBinding with renderValue() handles custom outputs.\nFor production applications, prioritize using htmltools::htmlDependency() for asset management, implement proper rate limiting, handle validation states, and ensure cleanup in unsubscribe(). The htmlwidgets framework significantly reduces boilerplate for visualization outputs. Testing with shinytest2 and debugging with options(shiny.trace = TRUE) catch issues before deployment. As the ecosystem matures, the posit-dev/shiny-bindings repository provides emerging patterns for React component integration, pointing toward increasingly sophisticated component architectures."
  },
  {
    "objectID": "research.html#bibtex-citations-for-use-with-pandoc-or-quarto",
    "href": "research.html#bibtex-citations-for-use-with-pandoc-or-quarto",
    "title": "Creating custom R Shiny inputs and outputs: A comprehensive guide",
    "section": "",
    "text": "@online{posit2024shiny,\n  author = {{Posit Software, PBC}},\n  title = {Shiny for R: Articles and Documentation},\n  year = {2024},\n  url = {https://shiny.posit.co/r/articles/},\n  note = {Accessed: 2025-11-26}\n}\n\n@online{posit2024custominput,\n  author = {{Posit Software, PBC}},\n  title = {How to Create Custom Input Bindings},\n  year = {2024},\n  url = {https://shiny.posit.co/r/articles/build/js-custom-input/},\n  note = {Accessed: 2025-11-26}\n}\n\n@online{posit2024buildinginputs,\n  author = {{Posit Software, PBC}},\n  title = {Build Custom Input Objects},\n  year = {2024},\n  url = {https://shiny.posit.co/r/articles/build/building-inputs/},\n  note = {Accessed: 2025-11-26}\n}\n\n@online{posit2024communicatingjs,\n  author = {{Posit Software, PBC}},\n  title = {Communicating with Shiny via JavaScript},\n  year = {2024},\n  url = {https://shiny.posit.co/r/articles/build/communicating-with-js/},\n  note = {Accessed: 2025-11-26}\n}\n\n@online{posit2024packagingjs,\n  author = {{Posit Software, PBC}},\n  title = {Packaging JavaScript Code for Shiny},\n  year = {2024},\n  url = {https://shiny.posit.co/r/articles/build/packaging-javascript/},\n  note = {Accessed: 2025-11-26}\n}\n\n@online{posit2024buildingoutputs,\n  author = {{Posit Software, PBC}},\n  title = {Build Custom Output Objects},\n  year = {2024},\n  url = {https://shiny.posit.co/r/articles/build/building-outputs/},\n  note = {Accessed: 2025-11-26}\n}\n\n@book{wickham2021mastering,\n  author = {Wickham, Hadley},\n  title = {Mastering Shiny: Build Interactive Apps, Reports, and Dashboards Powered by R},\n  year = {2021},\n  publisher = {O'Reilly Media},\n  isbn = {978-1-492-04738-4},\n  url = {https://mastering-shiny.org/},\n  note = {Accessed: 2025-11-26}\n}\n\n@book{coene2021javascript,\n  author = {Coene, John},\n  title = {JavaScript for R},\n  year = {2021},\n  publisher = {Chapman and Hall/CRC},\n  series = {The R Series},\n  isbn = {978-0-367-68063-3},\n  url = {https://javascript-for-r.com/},\n  note = {Accessed: 2025-11-26}\n}\n\n@book{granjon2022outstanding,\n  author = {Granjon, David},\n  title = {Outstanding User Interfaces with Shiny},\n  year = {2022},\n  publisher = {Chapman and Hall/CRC},\n  series = {The R Series},\n  isbn = {978-0-367-64365-2},\n  doi = {10.1201/9781003124924},\n  url = {https://unleash-shiny.rinterface.com/},\n  note = {Accessed: 2025-11-26}\n}\n\n@book{fay2021engineering,\n  author = {Fay, Colin and Rochette, S√©bastien and Guyader, Vincent and Girard, Cervan},\n  title = {Engineering Production-Grade Shiny Apps},\n  year = {2021},\n  publisher = {Chapman and Hall/CRC},\n  series = {The R Series},\n  isbn = {978-0-367-46602-2},\n  doi = {10.1201/9781003029878},\n  url = {https://engineering-shiny.org/},\n  note = {Accessed: 2025-11-26}\n}\n\n@manual{htmlwidgets2024,\n  title = {htmlwidgets: HTML Widgets for R},\n  author = {Vaidyanathan, Ramnath and Xie, Yihui and Allaire, JJ and Cheng, Joe and Sievert, Carson and Russell, Kenton},\n  year = {2024},\n  note = {R package version 1.6.4},\n  url = {https://CRAN.R-project.org/package=htmlwidgets}\n}\n\n@online{htmlwidgets_develop,\n  author = {Vaidyanathan, Ramnath and Xie, Yihui and Allaire, JJ and Cheng, Joe and Sievert, Carson},\n  title = {Creating a Widget},\n  year = {2024},\n  url = {https://www.htmlwidgets.org/develop_intro.html},\n  note = {Accessed: 2025-11-26}\n}\n\n@online{htmlwidgets_sizing,\n  author = {Vaidyanathan, Ramnath and Xie, Yihui and Allaire, JJ and Cheng, Joe and Sievert, Carson},\n  title = {Widget Sizing},\n  year = {2024},\n  url = {https://www.htmlwidgets.org/develop_sizing.html},\n  note = {Accessed: 2025-11-26}\n}\n\n@manual{shinyWidgets2024,\n  title = {shinyWidgets: Custom Inputs Widgets for Shiny},\n  author = {Perrier, Victor and Meyer, Fanny and Granjon, David},\n  year = {2024},\n  note = {R package version 0.8.7},\n  url = {https://CRAN.R-project.org/package=shinyWidgets}\n}\n\n@manual{shinyjs2024,\n  title = {shinyjs: Easily Improve the User Experience of Your Shiny Apps in Seconds},\n  author = {Attali, Dean},\n  year = {2024},\n  url = {https://CRAN.R-project.org/package=shinyjs}\n}\n\n@manual{reactR2024,\n  title = {reactR: React Helpers},\n  author = {Russell, Kent and Dipert, Alan},\n  year = {2024},\n  url = {https://CRAN.R-project.org/package=reactR}\n}\n\n@manual{shinyreact2024,\n  title = {shiny.react: Tools for Using React in Shiny},\n  author = {Sobolewski, Jakub and ≈ªy≈Ça, Kamil and Rogala, Marek and {Appsilon Sp. z o.o.}},\n  year = {2024},\n  url = {https://CRAN.R-project.org/package=shiny.react}\n}\n\n@manual{golem2024,\n  title = {golem: A Framework for Robust Shiny Applications},\n  author = {Fay, Colin and Guyader, Vincent and Rochette, S√©bastien and Girard, Cervan},\n  year = {2024},\n  url = {https://CRAN.R-project.org/package=golem}\n}\n\n@online{r2d3_shiny,\n  author = {{RStudio}},\n  title = {Using r2d3 with Shiny},\n  year = {2024},\n  url = {https://rstudio.github.io/r2d3/articles/shiny.html},\n  note = {Accessed: 2025-11-26}\n}\n\n@online{shinytest2_docs,\n  author = {{Posit Software, PBC}},\n  title = {shinytest2: Testing Shiny Applications},\n  year = {2024},\n  url = {https://rstudio.github.io/shinytest2/},\n  note = {Accessed: 2025-11-26}\n}\n\n@online{shinyvalidate_displaying,\n  author = {Cheng, Joe and {Posit Software, PBC}},\n  title = {Displaying Validation Feedback},\n  year = {2024},\n  url = {https://rstudio.github.io/shinyvalidate/articles/displaying.html},\n  note = {Accessed: 2025-11-26}\n}\n\n@online{posit2024debugging,\n  author = {{Posit Software, PBC}},\n  title = {Debugging Shiny Applications},\n  year = {2024},\n  url = {https://shiny.posit.co/r/articles/improve/debugging/},\n  note = {Accessed: 2025-11-26}\n}\n\n@misc{shiny_github,\n  author = {{Posit Software, PBC}},\n  title = {Shiny: Web Application Framework for R},\n  year = {2024},\n  publisher = {GitHub},\n  url = {https://github.com/rstudio/shiny},\n  note = {Accessed: 2025-11-26}\n}\n\n@misc{shinybindings_github,\n  author = {{Posit Software, PBC}},\n  title = {Shiny Bindings: JavaScript Packages for Custom Bindings},\n  year = {2024},\n  publisher = {GitHub},\n  url = {https://github.com/posit-dev/shiny-bindings},\n  note = {Accessed: 2025-11-26}\n}"
  }
]